---
layout: post
title: "Clojure实战(3)：使用Noir框架开发博客(下)"
date: 2012-12-16 20:20
comments: true
categories: Tutorial
tags: [clojure, noir]
published: false
---

Session和Cookie
---------------

做网络编程的人肯定对这两个概念不陌生，因此这里就不介绍它们的定义和作用了。我们要实现的需求也很简单：用户通过一个表单登录，在当前窗口中保持登录状态，并可以选择“记住我”来免去关闭并新开窗口之后的重登录。显然，前者使用Session，后者使用Cookie。下面我们就来看Noir对这两者的支持。

### Session

```clojure
(require 'noir.session)
(noir.session/put! :username "john")
(noir.session/get :username "nobody")
(noir.session/clear!)
```

很简单的API。注意`put!`函数中的`!`，和之前遇到的`?`一样，这种特殊字符是合法的函数名，但`!`习惯用来表示该方法会改变某个对象的状态，这里`put!`就表示会改变Session的状态。

Noir还提供了一种“闪信（Flash）”机制，主要用于在页面跳转之间暂存消息。如用户登录后会跳转到首页，如果想在首页显示“登录成功”的信息，就需要用到闪信了。闪信的API也放置在`noir.session`命名空间下：

```clojure
(noir.session/flash-put! "登录成功")
(noir.session/flash-get)
```

闪信的生命周期是一次请求，即在设置了闪信后的下一个请求中，可以多次`flash-get`，但再下一次请求就获取不到值了。

### Cookie

Cookie的API示例如下：

```clojure
(require 'noir.cookies)
(noir.cookies/put! :user_id (str 1))
(noir.cookies/get :user_id)
(noir.cookies/put! :tracker {:value (str 29649) :path "/" :max-age 3600})
```

需要注意的是，`put!`函数只支持字符串类型；对于Cookie超时时间的设置，一种是上面所写的多少秒过期，另一种是传入一个DateTime对象。对于时间日期的处理，Java自带的类库可能不太好用，这里推荐[Joda Time](http://joda-time.sourceforge.net/)，它有更丰富的功能和更友善的API。

登录页面
--------

这里我们跳过注册页面，因为它实现的功能和新建一篇文章很相近，所以读者可以自己完成。我们假定用户信息表的格式如下：

```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(32) NOT NULL,
  PRIMARY KEY (`id`)
)
```

其中password字段保存的是密码的MD5值（32位16进制字符串）。Clojure中没有提供专门的类库，因此需要调用Java来实现。下文会贴出它的实现代码。

我们重点来看对登录页面表单的处理。新建`src/blog/views/login.clj`文件，添加对`/login`的路由，显示一个包含用户名、密码、以及“记住我”复选框的表单。用户提交后，若验证成功，会跳转至`/whoami`页面，用来显示保存在session或者cookie中的信息。以下是关键代码：

```clojure
(defpage [:post "/login"] {:as forms}
  (let [userid (model-user/get-id (:username forms) (:password forms))]
    (if userid
      (do (session/put! :userid userid)
          (session/put! :username (:username forms))
          (when (= (:remember-me forms) "1") ; “记住我”复选框
            (cookies/put! :userid {:value (str userid) :max-age 86400}) ; 保存登录状态，时限1天。
            (cookies/put! :username {:value (:username forms) :max-age 86400}))
          (response/redirect "/whoami")) ; noir.response/redirect 302跳转
      (render "/login" forms))))

(defpage "/whoami" [] ; 先检测Session，再检测Cookie。
  (let [userid (session/get :userid)
        username (session/get :username)]
    (if userid
      username
      (let [userid (cookies/get :userid)
            username (cookies/get :username)]
        (if userid
          (do
            (session/put! :userid userid)
            (session/put! :username username)
            username)
          "unknown")))))
```

对用户表的操作我们放到`src/blog/models/user.clj`文件中：

```clojure
(ns blog.models.user
  (:require [clojure.java.jdbc :as sql]
            [blog.util :as util])
  (:use [blog.database :only [db-spec]]))

(defn get-id [username password]
  (let [password-md5 (util/md5 password)]
    (sql/with-connection db-spec
      (sql/with-query-results rows
        ["SELECT `id` FROM `user` WHERE `username` = ? AND `password` = ?"
         username password-md5] ; 不要采用直接拼接字符串的方式，有SQL注入的危险。
        (:id (first rows))))))
```

最后，我们将MD5加密这类的函数放到`src/blog/util.clj`文件中：

```clojure
(ns blog.util
  (:import java.security.MessageDigest
           java.math.BigInteger))

(defn md5 [s]
  (let [algorithm (MessageDigest/getInstance "MD5")
        size (* 2 (.getDigestLength algorithm))
        raw (.digest algorithm (.getBytes s))
        sig (.toString (BigInteger. 1 raw) 16)
        padding (apply str (repeat (- size (count sig)) "0"))]
    (str padding sig)))
```

`padding`的作用是当计算得到的MD5字符串不足32位时做补零的操作。如何得到一个包含N个"0"的字符串？这就是`(apply...)`那串代码做的工作。简单来说，`repeat`函数会返回一个序列，`apply`函数首先使用第1、第2个元素作为参数调用`str`函数，然后将执行结果和第3个元素作为参数调用`str`，依此类推。因此，`(apply str [1 2 3])`等价于`(str (str 1 2) 3)`。`clojure.string/join`提供了将序列连接为字符串的功能，用法是`(clojure.string/join (repeat ...))`，查看它的源码`(source clojure.string/join)`可以发现，它实质上也是采用了`apply`函数。

序列是Clojure的一个很重要的数据结构，有多种函数和惯用法，需要逐步积累这些知识。
