
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Clojure 代码规范 - Ji ZHANG's Blog</title>
  <meta name="author" content="Ji ZHANG">

  
  <meta name="description" content="原文地址：https://github.com/bbatsov/clojure-style-guide 这份Clojure代码规范旨在提供一系列的最佳实践，让现实工作中的Clojure程序员能够写出易于维护的代码，并能与他人协作和共享。一份反应真实需求的代码规范才能被人接收，而那些理想化的、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jizhang.github.com/blog/2012/01/04/clojure-style-guide/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Ji ZHANG's Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37223379-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Ji ZHANG's Blog</a></h1>
  
    <h2>If I rest, I rust.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jizhang.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/categories/tutorial">Tutorial</a></li>
  <li><a href="/blog/categories/translation">Translation</a></li>
  <li><a href="/blog/categories/ops">Ops</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Clojure 代码规范</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-04T20:49:00+08:00" pubdate data-updated="true">Jan 4<span>th</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>原文地址：https://github.com/bbatsov/clojure-style-guide</p>

<p>这份Clojure代码规范旨在提供一系列的最佳实践，让现实工作中的Clojure程序员能够写出易于维护的代码，并能与他人协作和共享。一份反应真实需求的代码规范才能被人接收，而那些理想化的、甚至部分观点遭到程序员拒绝的代码规范注定不会长久——无论它有多出色。</p>

<p>这份规范由多个章节组成，每个章节包含一组相关的规则。我会尝试去描述每条规则背后的理念（过于明显的理念我就省略了）。</p>

<p>这些规则并不是我凭空想象的，它们出自于我作为一个专业软件开发工程师长久以来的工作积累，以及Clojure社区成员们的反馈和建议，还有各种广为流传的Clojure编程学习资源，如<a href="http://www.clojurebook.com/">《Clojure Programming》</a>、<a href="http://joyofclojure.com/">《The Joy of Clojure》</a>等。</p>

<p>这份规范还处于编写阶段，部分章节有所缺失，内容并不完整；部分规则没有示例，或者示例还不能完全将其描述清楚。未来这些问题都会得到改进，只是请你了解这一情况。</p>

<p>你可以使用<a href="https://github.com/TechnoGate/transmuter">Transmuter</a>生成一份本规范的PDF或HTML格式的文档。</p>

<h2>目录</h2>

<ul>
<li><a href="#source-code-layout--organization">源代码的布局和组织结构</a></li>
<li><a href="#syntax">语法</a></li>
<li><a href="#naming">命名</a></li>
<li><a href="#comments">注释</a>

<ul>
<li><a href="#comment-annotations">注释中的标识</a></li>
</ul>
</li>
<li><a href="#exceptions">异常</a></li>
<li><a href="#collections">集合</a></li>
<li><a href="#mutation">可变量</a></li>
<li><a href="#strings">字符串</a></li>
<li><a href="#regular-expressions">正则表达式</a></li>
<li><a href="#macros">宏</a></li>
<li><a href="#existential">惯用法</a></li>
</ul>


<h2><a name="source-code-layout--organization"></a>源代码的布局和组织结构</h2>

<blockquote><p>几乎所有人都认为任何代码风格都是丑陋且难以阅读的，除了自己的之外。把这句话中的“除了自己之外”去掉，那差不多就能成立了。
—— Jerry Coffin 关于代码缩进的评论</p></blockquote>

<ul>
<li><p>使用两个 <strong>空格</strong> 进行缩进，不使用制表符。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (when something</p>

<pre><code>(something-else))
</code></pre>

  ;; 错误 - 四个空格
  (when something

<pre><code>  (something-else))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>纵向对齐函数参数。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (filter even?</p>

<pre><code>      (range 1 10))
</code></pre>

  ;; 错误
  (filter even?

<pre><code>(range 1 10))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>对齐let绑定，以及map类型中的关键字。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (let [thing1 &#8220;some stuff&#8221;</p>

<pre><code>    thing2 "other stuff"]
{:thing1 thing1
 :thing2 thing2})
</code></pre>

  ;; 错误
  (let [thing1 &#8220;some stuff&#8221;

<pre><code>thing2 "other stuff"]
{:thing1 thing1
:thing2 thing2})
</code></pre>

<p>  &#8220;`</p></li>
<li><p>当<code>defn</code>没有文档字符串时，可以选择省略函数名和参数列表之间的空行。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn foo</p>

<pre><code>[x]
(bar x))
</code></pre>

  ;; 正确
  (defn foo [x]

<pre><code>(bar x))
</code></pre>

  ;; 错误
  (defn foo

<pre><code>[x] (bar x))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>当函数体较简短时，可以选择忽略参数列表和函数体之间的空行。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn foo [x]</p>

<pre><code>(bar x))
</code></pre>

<p>  ;; 适合简单的函数
  (defn goo [x] (bar x))</p>

<p>  ;; 适合包含多种参数列表的函数
  (defn foo</p>

<pre><code>([x] (bar x))
([x y]
  (if (predicate? x)
    (bar x)
    (baz x))))
</code></pre>

  ;; 错误
  (defn foo

<pre><code>[x] (if (predicate? x)
      (bar x)
      (baz x)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>跨行的文档说明字符串每行都要缩进。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn foo</p>

<pre><code>"Hello there. This is
a multi-line docstring."
[]
(bar))
</code></pre>

  ;; 错误
  (defn foo

<pre><code>"Hello there. This is
</code></pre>

  a multi-line docstring.&#8221;

<pre><code>[]
(bar))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用Unix风格的换行符（*BSD、Solaris、Linux、OSX用户无需设置，Windows用户则需要格外注意了）</p>

<ul>
<li><p>如果你使用Git，为了防止项目中意外引入Windows风格的换行符，不妨添加如下设置：</p>

<p>  <code>bash
  $ git config --global core.autocrlf true
 </code></p></li>
</ul>
</li>
<li><p>在括号<code>(</code>、<code>{</code>、<code>[</code>、<code>]</code>、<code>}</code>、<code>)</code>的外部添加空格，括号内部不要添加。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (foo (bar baz) quux)</p>

<p>  ;; 错误
  (foo(bar baz)quux)
  (foo ( bar baz ) quux)
  &#8220;`</p></li>
<li><p>避免在集合中使用逗号分隔符。</p>

<p>  &#8220;`Clojure
  ;; 正确
  [1 2 3]
  (1 2 3)</p>

<p>  ;; 错误
  [1, 2, 3]
  (1, 2, 3)
  &#8220;`</p></li>
<li><p>可以考虑在map中适当使用逗号和换行以增强可读性。</p>

<p>  &#8220;`Clojure
  ;; 正确
  {:name &#8220;Bruce Wayne&#8221; :alter-ego &#8220;Batman&#8221;}</p>

<p>  ;; 正确，且会增强可读性
  {:name &#8220;Bruce Wayne&#8221;
   :alter-ego &#8220;Batman&#8221;}</p>

<p>  ;; 正确，且较为紧凑
  {:name &#8220;Bruce Wayne&#8221;, :alter-ego &#8220;Batman&#8221;}
  &#8220;`</p></li>
<li><p>将所有的反括号放在一行中。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (when something</p>

<pre><code>(something-else))
</code></pre>

  ;; 错误
  (when something

<pre><code>(something-else)
</code></pre>

<p>  )
  &#8220;`</p></li>
<li><p>顶层函数之间空出一行。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (def x &#8230;)</p>

<p>  (defn foo &#8230;)</p>

<p>  ;; 错误
  (def x &#8230;)
  (defn foo &#8230;)
  &#8220;`</p></li>
<li><p>函数或宏的定义体中不要添加空行。</p></li>
<li>每行尽量不超过80个字符。</li>
<li>避免在行末输入多余的空格。</li>
<li>为每个命名空间创建单独的文件。</li>
<li><p>使用一个完整的<code>ns</code>指令来声明命名空间，其包含<code>import</code>、<code>require</code>、<code>refer</code>、以及<code>use</code>。</p>

<p>  &#8220;`Clojure
  (ns examples.ns</p>

<pre><code>(:refer-clojure :exclude [next replace remove])
(:require (clojure [string :as string]
                   [set :as set])
          [clojure.java.shell :as sh])
(:use (clojure zip xml))
(:import java.util.Date
         java.text.SimpleDateFormat
         (java.util.concurrent Executors
                               LinkedBlockingQueue)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>避免使用只有一个元素的命名空间名。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (ns example.ns)</p>

<p>  ;; 错误
  (ns example)
  &#8220;`</p></li>
<li><p>避免使用过长的命名空间（不超过五个元素）。</p></li>
<li><p>一个函数不应超过10行代码。事实上，大多数函数应保持在5行代码以内。</p></li>
<li><p>函数的参数个数不应超过三到四个。</p></li>
</ul>


<h2><a name="syntax"></a>语法</h2>

<ul>
<li>避免使用<code>require</code>、<code>refer</code>等改变命名空间的函数，它们只应在REPL中使用。</li>
<li>使用<code>declare</code>实现引用传递。</li>
<li><p>优先使用<code>map</code>这类高阶函数，而非<code>loop/recur</code>。</p></li>
<li><p>优先使用前置、后置条件来检测函数参数和返回值：</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn foo [x]</p>

<pre><code>{:pre [(pos? x)]}
(bar x))
</code></pre>

  ;; 错误
  (defn foo [x]

<pre><code>(if (pos? x)
  (bar x)
  (throw (IllegalArgumentException "x must be a positive number!")))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>不要在函数中定义变量：</p>

<p>  &#8220;`Clojure
  ;; 非常糟糕
  (defn foo []</p>

<pre><code>(def x 5)
...)
</code></pre>

<p>  &#8220;`</p></li>
<li><p>本地变量名不应覆盖<code>clojure.core</code>中定义的函数：</p>

<p>  <code>``Clojure
  ;; 错误——这样一来函数中调用</code>map`时就需要指定完整的命名空间了。
  (defn foo [map]</p>

<pre><code>...)
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>seq</code>来判断一个序列是否为空（空序列等价于nil）。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn print-seq [s]</p>

<pre><code>(when (seq s)
  (prn (first s))
  (recur (rest s))))
</code></pre>

  ;; 错误
  (defn print-seq [s]

<pre><code>(when-not (empty? s)
  (prn (first s))
  (recur (rest s))))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>when</code>替代<code>(if ... (do ...)</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (when pred</p>

<pre><code>(foo)
(bar))
</code></pre>

  ;; 错误
  (if pred

<pre><code>(do
  (foo)
  (bar)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>if-let</code>替代<code>let</code> + <code>if</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (if-let [result :foo]</p>

<pre><code>(something-with result)
(something-else))
</code></pre>

  ;; 错误
  (let [result :foo]

<pre><code>(if result
  (something-with result)
  (something-else)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>when-let</code>替代<code>let</code> + <code>when</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (when-let [result :foo]</p>

<pre><code>(do-something-with result)
(do-something-more-with result))
</code></pre>

  ;; 错误
  (let [result :foo]

<pre><code>(when result
  (do-something-with result)
  (do-something-more-with result)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>if-not</code>替代<code>(if (not ...) ...)</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (if-not (pred)</p>

<pre><code>(foo))
</code></pre>

  ;; 错误
  (if (not pred)

<pre><code>(foo))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>when-not</code>替代<code>(when (not ...) ...)</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (when-not pred</p>

<pre><code>(foo)
(bar))
</code></pre>

  ;; 错误
  (when (not pred)

<pre><code>(foo)
(bar))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>not=</code>替代<code>(not (= ...))</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (not= foo bar)</p>

<p>  ;; 错误
  (not (= foo bar))
  &#8220;`</p></li>
<li><p>当匿名函数只有一个参数时，优先使用<code>%</code>，而非<code>%1</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  #(Math/round %)</p>

<p>  ;; 错误
  #(Math/round %1)
  &#8220;`</p></li>
<li><p>当匿名函数有多个参数时，优先使用<code>%1</code>，而非<code>%</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  #(Math/pow %1 %2)</p>

<p>  ;; 错误
  #(Math/pow % %2)
  &#8220;`</p></li>
<li><p>只有在必要的时候才使用匿名函数。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (filter even? (range 1 10))</p>

<p>  ;; 错误
  (filter #(even? %) (range 1 10))
  &#8220;`</p></li>
<li><p>当匿名函数包含多行语句时，使用<code>fn</code>来定义，而非<code>#(do ...)</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (fn [x]</p>

<pre><code>(println x)
(* x 2))
</code></pre>

  ;; 错误（你不得不使用<code>do</code>）
  #(do (println %)

<pre><code>   (* % 2))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>在特定情况下优先使用<code>complement</code>，而非匿名函数。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (filter (complement some-pred?) coll)</p>

<p>  ;; 错误
  (filter #(not (some-pred? %)) coll)
  &#8220;`</p></li>
</ul>


<p>当函数已存在对应的求反函数时，则应使用该求反函数（如<code>even?</code>和<code>odd?</code>）。</p>

<ul>
<li><p>某些情况下可以用<code>comp</code>使代码更简洁。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (map #(capitalize (trim %)) [&#8220;top &#8221; &#8221; test &#8220;])</p>

<p>  ;; 更好
  (map (comp capitalize trim) [&#8220;top &#8221; &#8221; test &#8220;])
  &#8220;`</p></li>
<li><p>某些情况下可以用<code>partial</code>使代码更简洁。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (map #(+ 5 %) (range 1 10))</p>

<p>  ;; 或许更好
  (map (partial + 5) (range 1 10))
  &#8220;`</p></li>
<li><p>当遇到嵌套调用时，建议使用<code>-&gt;</code>宏和<code>-&gt;&gt;</code>宏。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (-> [1 2 3]</p>

<pre><code>  reverse
  (conj 4)
  prn)
</code></pre>

  ;; 不够好
  (prn (conj (reverse [1 2 3])

<pre><code>         4))
</code></pre>

  ;; 正确
  (->> (range 1 10)

<pre><code>   (filter even?)
   (map (partial * 2)))
</code></pre>

  ;; 不够好
  (map (partial * 2)

<pre><code>   (filter even? (range 1 10)))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>当需要连续调用Java类的方法时，优先使用<code>..</code>，而非<code>-&gt;</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (-> (System/getProperties) (.get &#8220;os.name&#8221;))</p>

<p>  ;; 更好
  (.. System getProperties (get &#8220;os.name&#8221;))
  &#8220;`</p></li>
<li><p>在<code>cond</code>和<code>condp</code>中，使用<code>:else</code>来处理不满足条件的情况。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (cond</p>

<pre><code>(&lt; n 0) "negative"
(&gt; n 0) "positive"
:else "zero"))
</code></pre>

  ;; 错误
  (cond

<pre><code>(&lt; n 0) "negative"
(&gt; n 0) "positive"
true "zero"))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>当比较的变量和方式相同时，优先使用<code>condp</code>，而非<code>cond</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (cond</p>

<pre><code>(= x 10) :ten
(= x 20) :twenty
(= x 30) :forty
:else :dunno)
</code></pre>

  ;; 更好
  (condp = x

<pre><code>10 :ten
20 :twenty
30 :forty
:dunno)
</code></pre>

<p>  &#8220;`</p></li>
<li><p>当条件是常量时，优先使用<code>case</code>，而非<code>cond</code>或<code>condp</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (cond</p>

<pre><code>(= x 10) :ten
(= x 20) :twenty
(= x 30) :forty
:else :dunno)
</code></pre>

  ;; 更好
  (condp = x

<pre><code>10 :ten
20 :twenty
30 :forty
:dunno)
</code></pre>

  ;; 最佳
  (case x

<pre><code>10 :ten
20 :twenty
30 :forty
:dunno)
</code></pre>

<p>  &#8220;`</p></li>
<li><p>某些情况下，使用<code>set</code>作为判断条件。</p>

<p>  &#8220;`Clojure
  ;; 错误
  (remove #(= % 0) [0 1 2 3 4 5])</p>

<p>  ;; 正确
  (remove #{0} [0 1 2 3 4 5])</p>

<p>  ;; 错误
  (count (filter #(or (= % \a)</p>

<pre><code>                  (= % \e)
                  (= % \i)
                  (= % \o)
                  (= % \u))
             "mary had a little lamb"))
</code></pre>

<p>  ;; 正确
  (count (filter #{\a \e \i \o \u} &#8220;mary had a little lamb&#8221;))
  &#8220;`</p></li>
<li><p>使用<code>(inc x)</code>和<code>(dec x)</code>替代<code>(+ x 1)</code>和<code>(- x 1)</code>。</p></li>
<li><p>使用<code>(pos? x)</code>、<code>(neg? x)</code>、以及<code>(zero? x)</code>替代<code>(&gt; x 0)</code>、<code>(&lt; x 0)</code>、和<code>(= x 0)</code>。</p></li>
<li><p>进行Java操作时，优先使用Clojure提供的语法糖。</p>

<p>  &#8220;`Clojure
  ;;; 创建对象
  ;; 正确
  (java.util.ArrayList. 100)</p>

<p>  ;; 错误
  (new java.util.ArrayList 100)</p>

<p>  ;;; 调用静态方法
  ;; 正确
  (Math/pow 2 10)</p>

<p>  ;; 错误
  (. Math pow 2 10)</p>

<p>  ;;; 调用实例方法
  ;; 正确
  (.substring &#8220;hello&#8221; 1 3)</p>

<p>  ;; 错误
  (. &#8220;hello&#8221; substring 1 3)</p>

<p>  ;;; 访问静态属性
  ;; 正确
  Integer/MAX_VALUE</p>

<p>  ;; 错误
  (. Integer MAX_VALUE)</p>

<p>  ;;; 访问实例属性
  ;; 正确
  (.someField some-object)</p>

<p>  ;; 错误
  (. some-object some-field)
  &#8220;`</p></li>
</ul>


<h2><a name="naming"></a>命名</h2>

<blockquote><p>编程中真正的难点只有两个：验证缓存的有效性；命名。<br/>
—— Phil Karlton</p></blockquote>

<ul>
<li>命名空间建议使用以下两种方式：

<ul>
<li><code>项目名称.模块名称</code></li>
<li><code>组织名称.项目名称.模块名称</code></li>
</ul>
</li>
<li>对于命名空间中较长的元素，使用<code>lisp-case</code>格式，如<code>bruce.project-euler</code>。</li>
<li>使用<code>lisp-case</code>格式来命名函数和变量。</li>
<li>使用<code>CamelCase</code>来命名接口（protocol）、记录（record）、结构和类型（struct &amp; type）。对于HTTP、RFC、XML等缩写，仍保留其大写格式。</li>
<li>对于返回布尔值的函数名称，使用问号结尾，如<code>even?</code>。</li>
<li>当方法或宏不能在STM中安全使用时，须以感叹号结尾，如<code>reset!</code>。</li>
<li><p>命名类型转换函数时使用<code>-&gt;</code>，而非<code>to</code>。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (defn f->c &#8230;)</p>

<p>  ;; 不够好
  (defn f-to-c &#8230;)
  &#8220;`</p></li>
<li><p>对于可供重绑定的变量（即动态变量），使用星号括起，如<code>*earmuffs*</code>。</p></li>
<li>无需对常量名进行特殊的标识，因为所有的变量都应该是常量，除非有特别说明。</li>
<li>对于解构过程中或参数列表中忽略的元素，使用<code>_</code>来表示。</li>
<li>参考<code>clojure.core</code>中的命名规范，如<code>pred</code>、<code>coll</code>：

<ul>
<li>函数：

<ul>
<li><code>f</code>、<code>g</code>、<code>h</code>：参数内容是一个函数</li>
<li><code>n</code>：整数，通常是一个表示大小的值</li>
<li><code>index</code>：整数索引</li>
<li><code>x</code>、<code>y</code>：数值</li>
<li><code>s</code>：字符串</li>
<li><code>coll</code>：集合</li>
<li><code>pred</code>：断言型的闭包</li>
<li><code>&amp; more</code>：可变参数</li>
</ul>
</li>
<li>宏：

<ul>
<li><code>expr</code>：表达式</li>
<li><code>body</code>：语句</li>
<li><code>binding</code>：一个向量，包含宏的绑定</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2><a name="collections"></a>集合</h2>

<blockquote><p>用100种函数去操作同一种数据结构，要好过用10种函数操作10种数据结构。<br/>
—— Alan J. Perlis</p></blockquote>

<ul>
<li>避免使用列表（list）来存储数据（除非它真的就是你想要的）。</li>
<li><p>优先使用关键字（keyword），而非普通的哈希键：</p>

<p>  &#8220;`Clojure
  ;; 正确
  {:name &#8220;Bruce&#8221; :age 30}</p>

<p>  ;; 错误
  {&#8220;name&#8221; &#8220;Bruce&#8221; &#8220;age&#8221; 30}
  &#8220;`</p></li>
<li><p>编写集合时，优先使用内置的语法形式，而非构造函数。但是，在定义唯一值集合（set）时，只有当元素都是常量时才可使用内置语法，否则应使用构造函数，如下所示：</p>

<p>  &#8220;`Clojure
  ;; 正确
  [1 2 3]
  #{1 2 3}
  (hash-set (func1) (func2)) ; 元素在运行时确定</p>

<p>  ;; bad
  (vector 1 2 3)
  (hash-set 1 2 3)
  #{(func1) (func2)} ; 若(func1)和(func2)的值相等，则会抛出运行时异常。
  &#8220;`</p></li>
<li><p>避免使用数值索引来访问集合元素。</p></li>
<li><p>优先使用关键字来获取哈希表（map）中的值。</p>

<p>  &#8220;`Clojure
  (def m {:name &#8220;Bruce&#8221; :age 30})</p>

<p>  ;; 正确
  (:name m)</p>

<p>  ;; 错误——太过啰嗦
  (get m :name)</p>

<p>  ;; 错误——可能抛出空指针异常
  (m :name)
  &#8220;`</p></li>
<li><p>集合可以被用作函数：</p>

<p>  &#8220;`Clojure
  ;; 正确
  (filter #{\a \e \o \i \u} &#8220;this is a test&#8221;)</p>

<p>  ;; 缺点——不够美观
  &#8220;`</p></li>
<li><p>关键字可以被用作函数：</p>

<p>  <code>Clojure
  ((juxt :a :b) {:a "ala" :b "bala"})
 </code></p></li>
<li><p>只有在非常强调性能的情况下才可使用瞬时集合（transient collection）。</p></li>
<li><p>避免使用Java集合。</p></li>
<li><p>避免使用Java数组，除非遇到需要和Java类进行交互，或需要高性能地处理基本类型时才可使用。</p></li>
</ul>


<h2><a name="mutation"></a>可变量</h2>

<h3>引用（Refs）</h3>

<ul>
<li>建议所有的IO操作都使用<code>io!</code>宏进行包装，以免不小心在事务中调用了这些代码。</li>
<li>避免使用<code>ref-set</code>。</li>
<li>控制事务的大小，即事务所执行的工作越少越好。</li>
<li>避免出现短期事务和长期事务访问同一个引用（Ref）的情形。</li>
</ul>


<h3>代理（Agents）</h3>

<ul>
<li><code>send</code>仅使用于计算密集型、不会因IO等因素阻塞的线程。</li>
<li><code>send-off</code>则用于会阻塞、休眠的线程。</li>
</ul>


<h3>原子（Atoms）</h3>

<ul>
<li>避免在事务中更新原子。</li>
<li>避免使用<code>reset!</code>。</li>
</ul>


<h2><a name="strings"></a>字符串</h2>

<ul>
<li><p>优先使用<code>clojure.string</code>中提供的字符串操作函数，而不是Java中提供的或是自己编写的函数。</p>

<p>  &#8220;`Clojure
  ;; 正确
  (clojure.string/upper-case &#8220;bruce&#8221;)</p>

<p>  ;; 错误
  (.toUpperCase &#8220;bruce&#8221;)
  &#8220;`</p></li>
</ul>


<h2><a name="exceptions"></a>异常</h2>

<ul>
<li>复用已有的异常类型，如：

<ul>
<li><code>java.lang.IllegalArgumentException</code></li>
<li><code>java.lang.UnsupportedOperationException</code></li>
<li><code>java.lang.IllegalStateException</code></li>
<li><code>java.io.IOException</code></li>
</ul>
</li>
<li>优先使用<code>with-open</code>，而非<code>finally</code>。</li>
</ul>


<h2><a name="macros"></a>宏</h2>

<ul>
<li>如果可以用函数实现相同功能，不要编写一个宏。</li>
<li>首先编写一个宏的用例，尔后再编写宏本身。</li>
<li>尽可能将一个复杂的宏拆解为多个小型的函数。</li>
<li>宏只应用于简化语法，其核心应该是一个普通的函数。</li>
<li>使用语法转义（syntax-quote，即反引号），而非手动构造<code>list</code>。</li>
</ul>


<h2><a name="comments"></a>注释</h2>

<blockquote><p>好的代码本身就是文档。因此在添加注释之前，先想想自己该如何改进代码，让它更容易理解。做到这一点后，再通过注释让代码更清晰。<br/>
——Steve McConnel</p></blockquote>

<ul>
<li><p>学会编写容易理解的代码，然后忽略下文的内容。真的！</p></li>
<li><p>对于标题型的注释，使用至少四个分号起始。</p></li>
<li><p>对于顶层注释，使用三个分号起始。</p></li>
<li><p>为某段代码添加注释时，使用两个分号起始，且应与该段代码对齐。</p></li>
<li><p>对于行尾注释，使用一个分号起始即可。</p></li>
<li><p>分号后面要有一个空格。</p>

<p>  &#8220;`Clojure
  ;;;; Frob Grovel</p>

<p>  ;;; 这段代码有以下前提：
  ;;;   1. Foo.
  ;;;   2. Bar.
  ;;;   3. Baz.</p>

<p>  (defn fnord [zarquon]</p>

<pre><code>;; If zob, then veeblefitz.
(quux zot
      mumble             ; Zibblefrotz.
      frotz))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>对于成句的注释，句首字母应该大写，<a href="http://en.wikipedia.org/wiki/Sentence_spacing">句与句之间用一个空格分隔</a>。</p></li>
<li><p>避免冗余的注释：</p>

<p>  <code>Clojure
  ;; 错误
  (inc counter) ; counter变量的值加1
 </code></p></li>
<li><p>注释要和代码同步更新。过期的注释还不如没有注释。</p></li>
<li><p>有时，使用<code>#_</code>宏要优于普通的注释：</p>

<p>  &#8220;`Clojure
  ;; 正确
  (+ foo #_(bar x) delta)</p>

<p>  ;; 错误
  (+ foo</p>

<pre><code> ;; (bar x)
 delta)
</code></pre>

<p>  &#8220;`</p></li>
</ul>


<blockquote><p>好的代码和好的笑话一样，不需要额外的解释。
——Russ Olsen</p></blockquote>

<ul>
<li>避免使用注释去描述一段写得很糟糕的代码。重构它，让它更为可读。（做或者不做，没有尝试这一说。——Yoda）</li>
</ul>


<h3><a name="comment-annotations"></a>注释中的标识</h3>

<ul>
<li>标识应该写在对应代码的上一行。</li>
<li>标识后面是一个冒号和一个空格，以及一段描述文字。</li>
<li>如果标识的描述文字超过一行，则第二行需要进行缩进。</li>
<li><p>将自己姓名的首字母以及当前日期附加到标识描述文字中：</p>

<p>  &#8220;`Clojure
  (defn some-fun</p>

<pre><code>[]
;; FIXME: 这段代码在v1.2.3之后偶尔会崩溃，
;;        这可能和升级BarBazUtil有关。（xz 13-1-31）
(baz))
</code></pre>

<p>  &#8220;`</p></li>
<li><p>对于功能非常明显，实在无需添加注释的情况，可以在行尾添加一个标识：</p>

<p>  &#8220;`Clojure
  (defn bar</p>

<pre><code>[]
(sleep 100)) ; OPTIMIZE
</code></pre>

<p>  &#8220;`</p></li>
<li><p>使用<code>TODO</code>来表示需要后期添加的功能或特性。</p></li>
<li>使用<code>FIXME</code>来表示需要修复的问题。</li>
<li>使用<code>OPTIMIZE</code>来表示会引起性能问题的代码，并需要修复。</li>
<li>使用<code>HACK</code>来表示这段代码并不正规，需要在后期进行重构。</li>
<li>使用<code>REVIEW</code>来表示需要进一步审查这段代码，如：<code>REVIEW: 你确定客户会正确地操作X吗？</code></li>
<li>可以使用其它你认为合适的标识关键字，但记得一定要在项目的<code>README</code>文件中描述这些自定义的标识。</li>
</ul>


<h2><a name="existential"></a>惯用法</h2>

<ul>
<li>使用函数式风格进行编程，避免改变变量的值。</li>
<li>保持编码风格。</li>
<li>用正常人的思维来思考。</li>
</ul>


<h1>贡献</h1>

<p>本文中的所有内容都还没有最后定型，我很希望能够和所有对Clojure代码规范感兴趣的同仁一起编写此文，从而形成一份对社区有益的文档。</p>

<p>你可以随时创建讨论话题，或发送合并申请。我在这里提前表示感谢。</p>

<h1>宣传</h1>

<p>一份由社区驱动的代码规范如果得不到社区本身的支持和认同，那它就毫无意义了。发送一条推特，向朋友和同事介绍此文。任何评论、建议、以及意见都能够让我们向前迈进一小步。请让我们共同努力吧！</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Ji ZHANG</span></span>

      








  


<time datetime="2012-01-04T20:49:00+08:00" pubdate data-updated="true">Jan 4<span>th</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/translation/'>Translation</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://jizhang.github.com/blog/2012/01/04/clojure-style-guide/" data-via="zjerryj" data-counturl="http://jizhang.github.com/blog/2012/01/04/clojure-style-guide/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
      
        <a class="basic-alignment right" href="/blog/2012/11/16/aosa-git/" title="Next Post: 开源软件架构 - 卷2：第6章 Git">开源软件架构 - 卷2：第6章 Git &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/23/nginx-live-upgrade/">Nginx热升级</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/16/cia-noir-3/">Clojure实战(3)：使用Noir框架开发博客(下)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/08/cia-noir-2/">Clojure实战(2)：使用Noir框架开发博客(中)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/25/cia-noir-1/">Clojure实战(1)：使用Noir框架开发博客(上)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/18/aosa-python-packaging/">开源软件架构 - 卷1：第14章 Python打包工具</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("zjerryj", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/zjerryj" class="twitter-follow-button" data-show-count="false">Follow @zjerryj</a>
  
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/zjerryj?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/zjerryj">My Delicious Bookmarks &raquo;</a></p>
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/zhangji87@gmail.com?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Ji ZHANG -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jizhang';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://jizhang.github.com/blog/2012/01/04/clojure-style-guide/';
        var disqus_url = 'http://jizhang.github.com/blog/2012/01/04/clojure-style-guide/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
