<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translation | Ji ZHANG's Blog]]></title>
  <link href="http://shzhangji.com/blog/categories/translation/atom.xml" rel="self"/>
  <link href="http://shzhangji.com/"/>
  <updated>2013-06-15T23:22:28+08:00</updated>
  <id>http://shzhangji.com/</id>
  <author>
    <name><![CDATA[Ji ZHANG]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible FAQ]]></title>
    <link href="http://shzhangji.com/blog/2013/06/11/ansible-faq/"/>
    <updated>2013-06-11T21:18:00+08:00</updated>
    <id>http://shzhangji.com/blog/2013/06/11/ansible-faq</id>
    <content type="html"><![CDATA[<p>本文是从原Ansible官网的FAQ页面翻译而来，网站改版后该页面已无法访问，但可以从<a href="https://github.com/ansible/ansible.github.com/blob/4a2bf7f60a020f0d0a7b042056fc3dd8716588f2/faq.html">Github历史提交</a>中获得。翻译这篇原始FAQ文档是因为它陈述了Ansible这款工具诞生的原因，设计思路和特性，以及与Puppet、Fabric等同类软件的比较，可以让我们对Ansible有一个整体的了解，所以值得使用者一读。</p>

<h2>目录</h2>

<ul>
<li>为什么命名为“Ansible”？</li>
<li>Ansible受到了谁的启发？</li>
<li>与同类软件比较

<ul>
<li>Func？</li>
<li>Puppet？</li>
<li>Chef？</li>
<li>Capistrano/Fabric？</li>
</ul>
</li>
<li>其它问题

<ul>
<li>Ansible的安全性如何？</li>
<li>Ansible如何扩展？</li>
<li>是否支持SSH以外的协议？</li>
<li>Ansible的适用场景有哪些？</li>
</ul>
</li>
</ul>


<h2>为什么命名为“Ansible”？</h2>

<p>我最喜爱的书籍之一是奥森·斯科特·卡特的《安德的游戏》。在这本书中，“Ansible”是一种能够跨越时空的即时通讯工具。强烈推荐这本书！</p>

<!-- more -->


<h2>Ansible受到了谁的启发？</h2>

<p>我在Red Hat任职期间主要开发Cobbler，很快我和几个同事就发现在部署工具（Cobbler）和配置管理工具（cfengine、Puppet等）之间有一个空缺，即如何更高效地执行临时性的任务。虽然当时有一些并行调用SSH脚本的方案，但并没有形成统一的API。所以我们（Adrian Likins、Seth Vidal、我）就开发了一个SSH分布式脚本框架——Func。</p>

<p>我一直想在Func的基础上开发一个配置管理工具，但因为忙于Cobbler和其他项目的开发，一直没有动手。在此期间，John Eckersberg开发了名为Taboot的自动化部署工具，它基于Func，采用YAML描述，和目前Ansible中的Playbooks很像。</p>

<p>近期我在一家新公司尝试引入Func，但遇到一些SSL和DNS方面的问题，所以想要开发一个更为简单的工具，吸收Func中优秀的理念，并与我在Puppet Labs的工作经验相结合。我希望这一工具能够易于学习，且不需要进行任何安装步骤。使用它不需要引入一整套新的理论，像Puppet和Chef那样，从而降低被某些运维团队排挤的可能。</p>

<p>我也曾参与过一些大型网站的应用部署，发觉现有的配置管理工具都太过复杂了，超过了这些公司的需求。程序发布的过程很繁复，需要一个简单的工具来帮助开发和运维人员。我不想教授他们Puppet或Chef，而且他们也不愿学习这些工具。</p>

<p>于是我便思考，应用程序的部署就应该那么复杂吗？答案是否定的。</p>

<p>我是否能开发一款工具，让运维人员能够在15分钟内学会使用，并用自己熟悉的语言来扩展它？这就是Ansible的由来。运维人员对自己的服务器设施最清楚，Ansible深知这一点，并将同类工具中最核心的功能提取出来，供我们使用。</p>

<p>Ansible不仅易于学习和扩展，它更是集配置管理、应用部署、临时任务等功能于一身。它非常强大，甚至前所未有。</p>

<p>我很想知道你对Ansible的看法，到邮件列表里发表一下意见吧。</p>

<h2>与同类软件比较</h2>

<h3>Func？</h3>

<p>Ansible默认使用SSH，而非SSL和守护进程，无需在远程服务器上安装任何软件。你可以使用任何语言编写插件，只要它能够返回JSON格式即可。Ansible的API深受Func的影响，但它和Func相较提供了配置管理和多节点统一化部署（Playbooks）等功能。</p>

<h3>Puppet？</h3>

<p>首先我要强调的是，如果没有Puppet，就不会有Ansible。Puppet从cfengine中吸收了配置管理的概念，并更合理地加以实现。但是，我依旧认为它可以再简单一些。</p>

<p>Ansible的playbook是一套完整的配置管理系统。和Puppet不同，playbook在编写时就隐含了执行顺序（和Chef类似），但同时也提供了事件机制（和Puppet类似），可以说是结合了两者的优点。</p>

<p>Ansible没有中心节点的概念，从而避免了惊群效应。它一开始就是为多节点部署设计的，这点Puppet很难做到，因为它是一种“拉取”的架构。Ansible以“推送”为基础，从而能够定义执行顺序，同时只操作一部分服务器，无需关注它们的依赖关系。又因为Ansible可以用任何语言进行扩展，因此并不是只有专业的程序员才能为其开发插件。</p>

<p>Ansible中资源的概念深受Puppet的启发，甚至“state”这一关键字直接来自Puppet的“ensure”一词。和Puppet不同的是，Ansbile可以用任何语言进行扩展，甚至是Bash，只需返回JSON格式的输出即可。你不需要懂得Ruby。</p>

<p>和Puppet不同，Ansible若在配置某台服务器时发生错误，它会立即终止这台服务器的配置过程。它提倡的是“提前崩溃”，修正错误，而非最大化应用。这一点在我们需要配置包含依赖关系的服务器架构时尤为重要。</p>

<p>Ansible的学习曲线非常平滑，你不需要掌握编程技能，更不需要学习新的语言。Ansible内置的功能应该能够满足超过80%的用户需求，而且它不会遇到扩展性方面的瓶颈（因为没有中心节点）。</p>

<p>如果系统中安装了factor，Ansible同样支持从中获取系统信息。Ansible使用jinja2作为模板语言，类似于Puppet使用erb文件作为模板。Ansible可以使用自己的信息收集工具，因此factor并不是必需的。</p>

<h3>Chef？</h3>

<p>Ansible与Chef的区别和Puppet类似。Chef的配置非常困难，而且需要你掌握Ruby语言。也因为如此，Chef在Rails使用者中很流行。</p>

<p>Ansible是按照编写顺序来执行任务的，而不是显示地定义依赖关系，这点和Chef相似。但Ansible更进一步，它支持事件触发，比如修改了Apache的配置文件，Apache就会被重启。</p>

<p>和Chef不同的是，Ansible的playbook不是一门编程语言，而是一种可以存储的数据结构。这就意味着你的运维工作不是一项开发型的任务，测试起来也相对简单。</p>

<p>无论你有怎样的语言背景，都可以使用Ansible。Chef和Puppet有超过六万行的代码，而Ansible则是一段小巧简单的程序。我相信这一点会使得Ansible更加健壮和可靠，并汇聚一批活跃的社区贡献者——因为任何人都可以提交补丁或是模块。</p>

<p>Ansible同样支持从ohai中获取系统信息，当然这同样不是必需的。</p>

<h3>Capistrano/Fabric？</h3>

<p>这些工具并不适合用作服务器配置工具，它们主要用于应用程序的部署。</p>

<p>而Ansible则提供了完整的配置管理，以及在扩展性方面提供了一些高级特性。</p>

<p>Ansible playbook的语法简介只占一个HTML页面，有着非常平缓的学习曲线。由于Ansible使用了“推送”的设计，因此对系统管理员（不仅仅是开发者）同样适用，并能用它处理各种临时性的任务。</p>

<h2>其它问题</h2>

<h3>Ansible的安全性如何？</h3>

<p>Ansible没有守护进程，主要使用OpenSSH进行通信，这是一款已被反复检验并广泛使用的软件。其它工具都会在远程服务器上以root用户运行守护进程，因此相较于这些工具，Ansible会更为安全，且无需担心网络方面的问题。</p>

<p>如果你的中心节点遭到入侵（或是被恶意员工登录），只要你是使用SSH-agent、或是经过加密的密码，那你的密钥仍然是被锁定的，别人无法操控你的节点。而对于Chef、Puppet等工具来说，一旦配置文件遭到篡改，那危及的将是整个网络。</p>

<p>此外，由于Ansible没有守护进程，可以节省下一部分内存和计算资源，这对需要最大化性能的用户来说也是一个优点。</p>

<h3>Ansible如何扩展？</h3>

<p>无论是在单次执行模式还是playbook模式下，Ansible都可以并行执行任务，这要感谢Python提供的多进程处理模块。</p>

<p>你可以自行决定要一次性配置5台还是50台服务器，这取决于服务器的计算能力，以及你想要多快完成任务。</p>

<p>由于没有守护进程，所以平时不会占用任何资源，而且你不用担心一次性有太多节点一起从控制节点上获取信息。</p>

<p>对于SSH，Ansible默认使用paramiko库，当然也能使用原始的openssh。Ansible可以利用SSH的ControlMaster特性来重用网络连接。</p>

<p>当要维护上万个节点时，单个Ansible playbook可能不太合理，这时你就能使用Ansible的“拉取”模式。这种模式下需要配合git和cron，可以扩展到任意多台服务器。“拉取”模式可以使用本地连接，或是SSH。关于这个模式的详细说明可以在帮助文档的“Advanced Playbooks”一节查阅。即使在“拉取”模式下，你同样能够享受到Ansible的种种便利。</p>

<p>如果你想进一步探讨扩展性，可以加入到邮件列表中。</p>

<h3>是否支持SSH以外的协议？</h3>

<p>目前Ansible支持SSH和本地连接，但它的接口实际上是非常易于扩展的，因此你可以编写补丁来使Ansible运行于消息系统或XMPP协议之上。</p>

<p>如果你有任何建议，可以加入到邮件列表中一起探讨。Ansible中对于连接的管理都已单独抽象出来，有很强的可扩性。</p>

<h3>Ansible的适用场景有哪些？</h3>

<p>最适场景？使用playbook进行多节点云主机部署；从一个初始的操作系统开始部署应用，或是配置一个现有的系统。</p>

<p>Ansible同样适用于执行临时性的任务，能够用于各类 Unix-like 系统，因为它使用的就是系统本身自带的工具，无需安装额外软件。</p>

<p>你还可以用Ansible来编写各类脚本，用于收集信息、执行各种任务，对QA、运维等团队均适用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cascalog：基于Clojure的Hadoop查询语言]]></title>
    <link href="http://shzhangji.com/blog/2013/05/01/introducing-cascalog-a-clojure-based-query-language-for-hado/"/>
    <updated>2013-05-01T18:01:00+08:00</updated>
    <id>http://shzhangji.com/blog/2013/05/01/introducing-cascalog-a-clojure-based-query-language-for-hado</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://nathanmarz.com/blog/introducing-cascalog-a-clojure-based-query-language-for-hado.html">http://nathanmarz.com/blog/introducing-cascalog-a-clojure-based-query-language-for-hado.html</a></p>

<p>我非常兴奋地告诉大家，<a href="http://github.com/nathanmarz/cascalog">Cascalog</a>开源了！Cascalog受<a href="http://en.wikipedia.org/wiki/Datalog">Datalog</a>启发，是一种基于Clojure、运行于Hadoop平台上的查询语言。</p>

<h2>特点</h2>

<ul>
<li><strong>简单</strong> - 使用相同的语法编写函数、过滤规则、聚合运算；数据联合（join）变得简单而自然。</li>
<li><strong>表达能力强</strong> - 强大的逻辑组合条件，你可以在查询语句中任意编写Clojure函数。</li>
<li><strong>交互性</strong> - 可以在Clojure REPL中执行查询语句。</li>
<li><strong>可扩展</strong> - Cascalog的查询语句是一组MapReduce脚本。</li>
<li><strong>任意数据源</strong> - HDFS、数据库、本地数据、以及任何能够使用Cascading的<code>Tap</code>读取的数据。</li>
<li><strong>正确处理空值</strong> - 空值往往让事情变得棘手。Cascalog提供了内置的“非空变量”来自动过滤空值。</li>
<li><strong>与Cascading结合</strong> - 使用Cascalog定义的流程可以在Cascading中直接使用，反之亦然。</li>
<li><strong>与Clojure结合</strong> - 能够使用普通的Clojure函数来编写操作流程、过滤规则，又因为Cascalog是一种Clojure DSL，因此也能在其他Clojure代码中使用。</li>
</ul>


<!--more-->


<p>好，下面就让我们开始Cascalog的学习之旅！我会用一系列的示例来介绍Cascalog。这些示例会使用到项目本身提供的“试验场”数据集。我建议你立刻下载Cascalog，一边阅读本文一边在REPL中操作。（安装启动过程只有几分钟，README中有步骤）</p>

<h2>基本查询</h2>

<p>首先让我们启动REPL，并加载“试验场”数据集：</p>

<p><code>clojure
lein repl
user=&gt; (use 'cascalog.playground) (bootstrap)
</code></p>

<p>以上语句会加载本文用到的所有模块和数据。你可以阅读项目中的<code>playground.clj</code>文件来查看这些数据。下面让我们执行第一个查询语句，找出年龄为25岁的人：</p>

<p><code>clojure
user=&gt; (?&lt;- (stdout) [?person] (age ?person 25))
</code></p>

<p>这条查询语句可以这样阅读：找出所有<code>age</code>等于25的<code>?person</code>。执行过程中你可以看到Hadoop输出的日志信息，几秒钟后就能看到查询结果。</p>

<p>好，让我们尝试稍复杂的例子。我们来做一个范围查询，找出年龄小于30的人：</p>

<p><code>clojure
user=&gt; (?&lt;- (stdout) [?person] (age ?person ?age) (&lt; ?age 30))
</code></p>

<p>看起来也不复杂。这条语句中，我们将人的年龄绑定到了<code>?age</code>变量中，并对该变量做出了“小于30”的限定。</p>

<p>我们重新执行这条语句，只是这次会将人的年龄也输出出来：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?person ?age] (age ?person ?age)</p>

<pre><code>        (&lt; ?age 30))
</code></pre>

<p>```</p>

<p>我们要做的仅仅是将<code>?age</code>添加到向量中去。</p>

<p>让我们执行另一条查询，找出艾米丽关注的所有男性：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?person] (follows "emily" ?person)</p>

<pre><code>        (gender ?person "m"))
</code></pre>

<p>```</p>

<p>可能你没有注意到，这条语句使用了联合查询。各个数据集中的<code>?person</code>值都必须对应，而<code>follows</code>和<code>gender</code>分属于不同的数据集，Cascalog便会使用联合查询。</p>

<h2>查询语句的结构</h2>

<p>让我们分析一下查询语句的结构，以下面这条语句为例：</p>

<p>```clojure
user=> (?&lt;- [stdout] [?person ?a2] (age ?person ?age)</p>

<pre><code>        (&lt; ?age 30) (* 2 ?age :&gt; ?a2))
</code></pre>

<p>```</p>

<p><code>?&lt;-</code>操作符出现的频率很高，它能同时定义并执行一条查询。<code>?&lt;-</code>实际上是对<code>&lt;-</code>和<code>?-</code>的包装。我们之后会看到如何使用这些操作符编写更为复杂的查询语句。</p>

<p>首先，我们指定了查询结果的输出目的地，就是这里的<code>(stdout)</code>。<code>(stdout)</code>会创建一个Cascading的<code>tap</code>组件，它会在查询结束后将结果打印到标准输出中。我们可以使用任意一种Cascading的<code>tap</code>组件，也就是说输出结果的格式可以是序列文件（Sequence file）、文本文件等等；也可以输出到任何地方，如本地磁盘、HDFS、数据库等。</p>

<p>在定义了输出目的地后，我们使用Clojure的向量结构来定义输出结果所包含的内容。本例中，我们定义的是<code>?person</code>和<code>?a2</code>。</p>

<p>接下来，我们定义了一系列的约束条件。Cascalog有三种约束条件：</p>

<ol>
<li>生成器（Generator）：表示一个数据源，可以是以下两种类型：

<ul>
<li>Cascading Tap：如HDFS上某个路径中的文件；</li>
<li>一个已经使用<code>&lt;-</code>定义的查询。</li>
</ul>
</li>
<li>操作器（Operation）：引入预定义的变量，将其绑定至新的变量，或是设定一个过滤条件。</li>
<li>集合器（Aggregator）：计数、求和、最小值、最大值等等。</li>
</ol>


<p>约束条件由名称、一组输入变量、以及一组输出变量构成。上述查询中的约束条件有：</p>

<ul>
<li>(age ?person ?age)</li>
<li>(&lt; ?age 30)</li>
<li>(* 2 ?age :> ?a2)</li>
</ul>


<p>其中，<code>:&gt;</code>关键字用于将输入变量和输出变量隔开。如果没有这个关键字，那么该变量在操作器中就会被识别为输入变量，在生成器和集合器中会被认为是输出变量。</p>

<p><code>age</code>约束指向<code>playground.clj</code>中定义的一个<code>tap</code>，所以它是一个生成器，会输出<code>?person</code>和<code>?age</code>这两个数据。</p>

<p><code>&lt;</code>约束是一个Clojure函数，因为没有指定输出变量，所以这条约束会构成一个过滤器，将<code>?age</code>小于30的记录筛选出来。如果我们这样写：</p>

<p><code>clojure
(&lt; ?age 30 :&gt; ?young)
</code></p>

<p>那么<code>&lt;</code>约束会将“年龄是否小于30”作为一个布尔值传递给<code>?young</code>变量。</p>

<p>约束之间的顺序不重要，因为Cascalog是声明式语言。</p>

<h2>变量替换为常量</h2>

<p>变量是以<code>?</code>或<code>!</code>起始的标识。有时你不在意变量的值，可以直接用<code>_</code>代替。其他的变量则会在解析时替换成常量。我们已经在很多示例中用到这一特性了。下面这个示例中，我们将输出变量作为一种过滤条件：</p>

<p><code>clojure
(* 4 ?v2 :&gt; 100)
</code></p>

<p>这里使用了两个常量：4和100。4是一个输入变量，100则是作为一个过滤条件，只有满足<code>?v2</code>乘以4等于100的记录才会被筛选出来。字符串、数字、以及其他基本类型和对象类型，只要在Hadoop有对应的序列化操作，都可以被作为常量使用。</p>

<p>让我们回到示例中。找出所有关注了比自己年龄小的用户的列表：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?person1 ?person2]</p>

<pre><code>        (age ?person1 ?age1) (follows ?person1 ?person2)
        (age ?person2 ?age2) (&lt; ?age2 ?age1))
</code></pre>

<p>```</p>

<p>同时，我们将年龄差异也输出出来：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?person1 ?person2 ?delta]</p>

<pre><code>        (age ?person1 ?age1) (follows ?person1 ?person2)
        (age ?person2 ?age2) (- ?age2 ?age1 :&gt; ?delta)
        (&lt; ?delta 0))
</code></pre>

<p>```</p>

<h2>聚合</h2>

<p>下面让我们看看聚合查询的使用方法。统计所有年龄小于30的用户人数：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?count] (age _ ?a) (&lt; ?a 30)</p>

<pre><code>        (c/count ?count))
</code></pre>

<p>```</p>

<p>这条查询会统计所有的记录。我们也可以只聚合部分记录。比如，让我们找出每个人所关注的用户的数量：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?person ?count] (follows ?person _)</p>

<pre><code>        (c/count ?count))
</code></pre>

<p>```</p>

<p>因为我们在输出结果中指定了<code>?person</code>这个变量，所以Cascalog会将数据记录按照用户来分组，然后使用<code>c/count</code>进行聚合运算。</p>

<p>你可以在单个查询中使用多个聚合条件，它们的分组方式是一致的。例如，我们可以计算每个国家的用户的平均年龄，使用计数和求和这两种聚合方式：</p>

<p>```clojure
user=> (?&lt;- (stdout) [?country ?avg]</p>

<pre><code>        (location ?person ?country _ _) (age ?person ?age)
        (c/count ?count) (c/sum ?age :&gt; ?sum)
        (div ?sum ?count :&gt; ?avg))
</code></pre>

<p>```</p>

<p>可以看到，我们对<code>?sum</code>和<code>?count</code>这两个聚合结果执行了<code>div</code>操作，该操作会在聚合过程结束后进行。</p>

<h2>自定义操作</h2>

<p>下面我们来编写一个查询，统计几句话中每个单词的出现次数。首先，我们编写一个自定义操作：</p>

<p>```clojure
user=> (defmapcatop split [sentence]</p>

<pre><code>     (seq (.split sentence "\\s+")))
</code></pre>

<p>user=> (?&lt;- (stdout) [?word ?count] (sentence ?s)</p>

<pre><code>        (split ?s :&gt; ?word) (c/count ?count))
</code></pre>

<p>```</p>

<p><code>defmapcatop split</code>定义了一个方法，这个方法接收一个参数<code>sentence</code>，并会输出0个或多个元组（tuple）。<code>deffilterop</code>可以用来定义一个返回布尔型的方法，用来筛选记录；<code>defmapop</code>定义的函数会返回一个元组；<code>defaggregateop</code>定义一个聚合函数。这些函数都能在Cascalog工作流API中使用，我会在另一篇博客中叙述。</p>

<p>在上述查询中，如果单词字母大小写不一致，会被分别统计。我们用以下方法来修复这个问题：</p>

<p>```clojure
user=> (defn lowercase [w] (.toLowerCase w))
user=> (?&lt;- (stdout) [?word ?count]</p>

<pre><code>        (sentence ?s) (split ?s :&gt; ?word1)
        (lowercase ?word1 :&gt; ?word) (c/count ?count))
</code></pre>

<p>```</p>

<p>可以看到，这里直接使用了纯Clojure编写的函数。当这个函数不包含输出变量时，会被作为过滤条件来执行；当包含一个返回值时，则会作为<code>defmapop</code>来解析。而对于返回0个或多个元组的函数，则必须使用<code>defmapcatop</code>来定义。</p>

<p>下面这个查询会按照性别和年龄范围来统计用户数量：</p>

<p>```clojure
user=> (defn agebucket [age]</p>

<pre><code>     (find-first (partial &lt;= age) [17 25 35 45 55 65 100 200]))
</code></pre>

<p>user=> (?&lt;- (stdout) [?bucket ?gender ?count]</p>

<pre><code>        (age ?person ?age) (gender ?person ?gender)
        (agebucket ?age :&gt; ?bucket) (c/count ?count))
</code></pre>

<p>```</p>

<h2>非空变量</h2>

<p>Cascalog提供了“非空变量”这样的机制来帮助用户处理空值的情况。其实我们每个示例中都在使用这一特性。以<code>?</code>开头的变量都是非空变量，而以<code>!</code>开头的则是可空变量。Cascalog会在执行过程中将空值排除在外。</p>

<p>为了体验非空变量的效果，让我们对比下面这两条查询语句：</p>

<p><code>clojure
user=&gt; (?&lt;- (stdout) [?person ?city] (location ?person _ _ ?city)
user=&gt; (?&lt;- (stdout) [?person !city] (location ?person _ _ !city)
</code></p>

<p>第二组查询结果中会包含空值。</p>

<h2>子查询</h2>

<p>最后，我们来看看更为复杂的查询，我们会用到子查询这一特性。让我们找出关注了两人以上的用户列表，并找出这些用户之间的关注关系：</p>

<p>```clojure
user=> (let [many-follows (&lt;- [?person] (follows ?person _)</p>

<pre><code>                          (c/count ?c) (&gt; ?c 2))]
        (?&lt;- (stdout) [?person1 ?person2] (many-follows ?person1)
             (many-follows ?person2) (follows ?person1 ?person2)))
</code></pre>

<p>```</p>

<p>这里，我们使用<code>let</code>来定义了一个子查询<code>many-follows</code>。这个子查询是用<code>&lt;-</code>定义的。之后，我们便可以在后续查询中使用这个子查询了。</p>

<p>我们还可以在一个查询中指定多个输出目的地。比如我们想要同时得到<code>many-follows</code>的查询结果：</p>

<p>```clojure
user=> (let [many-follows (&lt;- [?person] (follows ?person _)</p>

<pre><code>                          (c/count ?c) (&gt; ?c 2))
         active-follows (&lt;- [?p1 ?p2] (many-follows ?p1)
                            (many-follows ?p2) (follows ?p1 ?p2))]
        (?- (stdout) many-follows (stdout) active-follows))
</code></pre>

<p>```</p>

<p>这里我们分别定义了两个查询，没有立刻执行它们，而是在后续的<code>?-</code>中将两个查询分别绑定到了两个<code>tap</code>上，并同时执行。</p>

<h2>小结</h2>

<p>Cascalog目前在还不断的改进中，未来会增加更多查询特性，以及对查询过程的优化。</p>

<p>我非常希望能够得到你对Cascalog的反馈，如果你有任何评论、问题、或是顾虑，请留言，或者在<a href="http://twitter.com/nathanmarz">Twitter</a>上联系我，给我发送邮件<a href="nathan.marz@gmail.com">nathan.marz@gmail.com</a>，或是在freenode的#cascading频道和我聊天。</p>

<p><a href="http://nathanmarz.com/blog/new-cascalog-features">下一篇博客</a>会介绍Cascalog的外联合、排序、组合等特性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[柯里化与偏应用（JavaScript描述）]]></title>
    <link href="http://shzhangji.com/blog/2013/03/07/currying-and-partial-application/"/>
    <updated>2013-03-07T20:59:00+08:00</updated>
    <id>http://shzhangji.com/blog/2013/03/07/currying-and-partial-application</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://raganwald.com/2013/03/07/currying-and-partial-application.html">http://raganwald.com/2013/03/07/currying-and-partial-application.html</a></p>

<p>上周末我参加了<a href="http://wrocloverb.com/">wroc_love.rb大会</a>，其间<a href="http://steveklabnik.com/">Steve Klabnik</a>的一张PPT中提到了<a href="https://en.wikipedia.org/wiki/Partial_application">偏应用（Partial Application）</a>和<a href="https://en.wikipedia.org/wiki/Currying">柯里化（Currying）</a>，并说这两者之间的区别如今已经不重要了。但是我不这么认为。</p>

<p>在这周发布的博文中，我用五种方式对<code>this</code>和闭包做了解释，但只有三到四种提到了柯里化。所以这篇博文就重点来谈谈这个。</p>

<h2>函数参数的个数</h2>

<p>在讲解之前，我们先明确一些术语。函数定义时会写明它所接收的参数个数（Arity）。“一元函数”（Unary）接收一个参数，“多元函数”（Polyadic）接收多个参数。还有一些特殊的名称，如“二元函数”（Binary）接收两个参数，“三元函数”（Ternary）接收三个参数等。你可以对照希腊语或拉丁语词汇来创造这些特殊的名称。</p>

<p>有些函数能够接收不定数量的参数，我们称之为“可变参数函数”（Variadic）。不过这类函数、以及不接收参数的函数并不是本文讨论的重点。</p>

<!-- more -->


<h2>偏应用</h2>

<p>偏应用的概念很容易理解，我们可以使用加法函数来做简单的演示，但如果你不介意的话，我想引用<a href="http://allong.es/">allong.es</a>这一JavaScript类库中的代码来做演示，而且它也是会在日常开发中用到的代码。</p>

<p>作为铺垫，我们首先实现一个<code>map</code>函数，用来将某个函数应用到数组的每个元素上：</p>

<p>```javascript
var __map = [].map;</p>

<p>function map (list, unaryFn) {
  return __map.call(list, unaryFn);
};</p>

<p>function square (n) {
  return n * n;
};</p>

<p>map([1, 2, 3], square);
  //=> [1, 4, 9]
```</p>

<p>显然，<code>map</code>是二元函数，<code>square</code>是一元函数。当我们使用<code>[1, 2, 3]</code>和<code>square</code>作为参数来调用<code>map</code>时，我们是将这两个参数 <em>应用（Apply）</em> 到<code>map</code>函数，并获得结果。</p>

<p>由于<code>map</code>函数接收两个参数，我们也提供了两个参数，所以说这是一次 <em>完整应用</em> 。那何谓偏应用（或部分应用）呢？其实就是提供少于指定数量的参数。如，仅提供一个参数来调用<code>map</code>。</p>

<p>如果我们只提供一个参数来调用<code>map</code>会怎么样？我们无法得到所要的结果，只能得到一个新的一元函数，通过调用这个函数并传递缺失的参数后，才能获得结果。</p>

<p>假设现在我们只提供一个参数给<code>map</code>，这个参数是<code>unaryFn</code>。我们从后往前来逐步实现，首先为<code>map</code>函数创建一个包装函数：</p>

<p><code>javascript
function mapWrapper (list, unaryFn) {
  return map(list, unaryFn);
};
</code></p>

<p>然后，我们将这个二元函数分割成两个嵌套的一元函数：</p>

<p>```javascript
function mapWrapper (unaryFn) {
  return function (list) {</p>

<pre><code>return map(list, unaryFn);
</code></pre>

<p>  };
};
```</p>

<p>这样一来，我们就能每次仅传递一个参数来进行调用了：</p>

<p><code>javascript
mapWrapper(square)([1, 2, 3]);
  //=&gt; [1, 4, 9]
</code></p>

<p>和之前的<code>map</code>函数相较，新的函数<code>mapWrapper</code>是一元函数，它的返回值是另一个一元函数，需要再次调用它才能获得返回值。那么偏应用要从何体现？让我们从第二个一元函数着手：</p>

<p>```javascript
var squareAll = mapWrapper(square);
  //=> [function]</p>

<p>squareAll([1, 2, 3]);
  //=> [1, 4, 9]
squareAll([5, 7, 5]);
  //=> [25, 49, 25]
```</p>

<p>我们首先将<code>square</code>这个参数部分应用到了<code>map</code>函数，并获得一个一元函数<code>squareAll</code>，它能实现我们需要的功能。偏应用后的<code>map</code>函数十分便捷，而<a href="http://allong.es/">allong.es</a>库中提供的<code>splat</code>函数做的也是相同的事情。</p>

<p>如果每次想要使用偏应用都需要手动编写这样一个包装函数，程序员显然会想到要自动化实现它。这就是下一节的内容：柯里化。</p>

<h2>柯里化</h2>

<p>首先，我们可以编写一个函数来返回包装器。我们仍然以二元函数为例：</p>

<p>```javascript
function wrapper (unaryFn) {
  return function (list) {</p>

<pre><code>return map(list, unaryFn);
</code></pre>

<p>  };
};
```</p>

<p>将函数<code>map</code>和参数名称替换掉：</p>

<p>```javascript
function wrapper (secondArg) {
  return function (firstArg) {</p>

<pre><code>return binaryFn(firstArg, secondArg);
</code></pre>

<p>  };
};
```</p>

<p>最后，我们再包装一层：</p>

<p>```javascript
function rightmostCurry (binaryFn) {
  return function (secondArg) {</p>

<pre><code>return function (firstArg) {
  return binaryFn(firstArg, secondArg);
};
</code></pre>

<p>  };
};
```</p>

<p>这样一来，我们之前使用的“模式”就抽象出来了。这个函数的用法是：</p>

<p>```javascript
var rightmostCurriedMap = rightmostCurry(map);</p>

<p>var squareAll = rightmostCurriedMap(square);</p>

<p>squareAll([1, 4, 9]);
  //=> [1, 4, 9]
squareAll([5, 7, 5]);
  //=> [25, 49, 25]
```</p>

<p>将一个多元函数转换成一系列一元函数的嵌套调用，这种转换称之为 <strong>柯里化</strong> 。它的名称取自其发明者Haskell Curry，他也重新定义了由<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">Moses Schönfinkel</a>提出的组合子逻辑（Combinatory Logic）。（<a href="#fn:birds">注1</a>）</p>

<p><code>rightmostCurry</code>函数可以将任意二元函数转换为一组一元函数，从传递第二个参数开始，因此才称其为“右起柯里化”。</p>

<p>和它相反的自然是“左起柯里化”，大多数逻辑学家使用“左起柯里化”，所以人们常说的柯里化指的也是左起柯里化：</p>

<p>```javascript
function curry (binaryFn) {
  return function (firstArg) {</p>

<pre><code>return function (secondArg) {
  return binaryFn(firstArg, secondArg);
};
</code></pre>

<p>  };
};</p>

<p>var curriedMap = curry(map),</p>

<pre><code>double = function (n) { n + n; };
</code></pre>

<p>var oneToThreeEach = curriedMap([1, 2, 3]);</p>

<p>oneToThreeEach(square);
  //=> [1, 4, 9]
oneToThreeEach(double);
  //=> [2, 4, 6]
```</p>

<p>那这两种柯里化方式应该如何选择呢？这就要看你的用途了。在上述二元函数的示例中，我们模拟的是一种“主体-客体”（Subject-Object）的语法。第一个参数表示主体，第二个参数表示客体。</p>

<p>当我们使用“右起柯里化”的<code>map</code>函数时，我们即假定主体是那个将被调用多次的函数（unaryFn）。</p>

<p>看到<code>squareAll([1, 2, 3])</code>时，我们会理解为“将数组[1, 2, 3]中的每个元素做平方运算”。使用“右起柯里化”，我们使平方运算成为主体，数组成为客体。而当使用一般的柯里化时，则是让数组作为主体，平方运算作为客体。</p>

<p>另一种理解的方式是看你需要重用哪一部分。通过不同的柯里化方式，你可以选择重用函数还是重用列表。</p>

<h2>再谈偏应用</h2>

<p>上文谈了那么多柯里化，那偏应用呢？事实上，当你有了柯里化，你就不需要偏应用了。同样地，当你使用了偏应用，也不会需要柯里化。所以当你需要为此撰写一篇文章时，最便捷的做法是先描述其中的一个，然后建立在其基础之上来描述另外一个。</p>

<p>首先让我们回顾一下右起柯里化：</p>

<p>```javascript
function rightmostCurry (binaryFn) {
  return function (secondArg) {</p>

<pre><code>return function (firstArg) {
  return binaryFn(firstArg, secondArg);
};
</code></pre>

<p>  };
};
```</p>

<p>你会发现在实际使用过程中会一直出现以下代码：</p>

<p>```javascript
var squareAll = rightmostCurry(map)(square),</p>

<pre><code>doubleAll = rightmostCurry(map)(double);
</code></pre>

<p>```</p>

<p>这种创建了柯里化函数后立刻调用的情况很常见，因此好事的人们就为它起了一个名字，称之为 <em>map函数的右起一元偏应用</em> 。</p>

<p>名字很长，我们分解开来看：</p>

<ol>
<li>右起：从最右边的参数开始；</li>
<li>一元：一个参数；</li>
<li>偏应用：只应用部分函数；</li>
<li>map：即<code>map</code>函数。</li>
</ol>


<p>所以我们实际上是想为<code>map</code>函数预先指定一个参数。它是一个二元函数，指定参数后便成了一元函数。在函数式编程语言或类库中，都提供了相应的方式来支持这种用法。</p>

<p>我们可以用柯里化来实现这样的功能：</p>

<p><code>javascript
function rightmostUnaryPartialApplication (binaryFn, secondArg) {
  return rightmostCurry(binaryFn)(secondArg);
};
</code></p>

<p>但更多时候我们会使用更为直接的方式：（<a href="#fn:caveat">注2</a>）</p>

<p>```javascript
function rightmostUnaryPartialApplication (binaryFn, secondArg) {
  return function (firstArg) {</p>

<pre><code>return binaryFn(firstArg, secondArg);
</code></pre>

<p>  };
};
```</p>

<p><code>rightmostUnaryPartialApplication</code>有些过长了，我们将其称为<code>applyLast</code>：</p>

<p><code>javascript
var applyLast = rightmostUnaryPartialApplication;
</code></p>

<p>这样，我们的<code>squareAll</code>和<code>doubleAll</code>函数就可以写为：</p>

<p>```javascript
var squareAll = applyLast(map, square),</p>

<pre><code>doubleAll = applyLast(map, double);
</code></pre>

<p>```</p>

<p>你同样可以实现一个<code>applyFirst</code>函数（我们就不提<code>leftmostUnaryPartialApplication</code>这种叫法了）：</p>

<p>```javascript
function applyFirst (binaryFn, firstArg) {
  return function (secondArg) {</p>

<pre><code>return binaryFn(firstArg, secondArg);
</code></pre>

<p>  };
};
```</p>

<p>和“左起/右起柯里化”一样，你应该在工具箱中保留这两种偏应用的方式，以便在实际使用过程中选择。</p>

<h2>柯里化和偏应用的区别</h2>

<p>“柯里化是将一个多元函数分解为一系列嵌套调用的一元函数。分解后，你可以部分应用一个或多个参数（<a href="#fn:also">注3</a>）。柯里化的过程不会向函数传递参数。”</p>

<p>“偏应用是为一个多元函数预先提供部分参数，从而在调用时可以省略这些参数。”</p>

<h2>这就是全部吗？</h2>

<p>是，但又不是。以下这些还请读者自行探索和实现：</p>

<ol>
<li>上文中，我们用柯里化实现了偏应用，那偏应用可以实现柯里化吗？为什么？（<a href="#fn:tao">注4</a>）</li>
<li>所有的示例都是将二元函数转换为一元函数，尝试写出一个更为通用的<code>applyFirst</code>和<code>applyLast</code>函数，能够为任意元的函数提供一个参数。如，假设有一个函数接收四个参数，那在使用了<code>applyFirst</code>后会返回一个接收三个参数的函数。</li>
<li>第2步完成后，再实现一组<code>applyLeft</code>和<code>applyRight</code>函数，它能为任意元的函数预先指定任意数量的参数，如，假设向<code>applyLeft</code>传递了一个三元函数和两个参数，那就会返回一个一元函数。</li>
<li>重写<code>curry</code>和<code>rightmostCurry</code>这两个函数，使其能够接收任意元的函数。一个三元函数柯里化后会产生三个嵌套调用的一元函数。</li>
<li>阅读<a href="http://allong.es/">allong.es</a>的代码，这是一个从<a href="http://leanpub.com/javascript-allonge">JavaScript Allongé</a>中提取的函数式编程类库。重点阅读它的partial_application.js文件。</li>
</ol>


<p>感谢你的阅读，如果你在代码中发现了Bug，请<a href="https://github.com/raganwald/raganwald.github.com">克隆这个镜像</a>，提交合并申请，或者<a href="https://github.com/raganwald/raganwald.github.com/issues">在Github上提交一个事务</a>。</p>

<p>PS：你可能会对另一篇文章也感兴趣：<a href="http://raganwald.com/2013/01/05/practical-applications-of-partial-application.html">Practical Applicaitons for Partial Application</a>。</p>

<p>（<a href="http://www.reddit.com/r/javascript/comments/19urej/whats_the_difference_between_currying_and_partial/">讨论</a>）</p>

<h2>脚注</h2>

<ol>
<li><a name="fn:birds"></a>当Raymond Smullyan为组合子逻辑撰写介绍时，他称之为“嘲鸟的模仿者”（To Mock a Mockingbird）。他通篇使用树林和小鸟来做比喻，以表达对Schönfinkel的敬意。Schön意为“美丽”，Fink则指德语中的Finch（燕雀），也指犹太语中的Finkl（火花）。所以他的名字可以理解为“美丽的燕雀”或“美丽的火花”。</li>
<li><a name="fn:caveat"></a>本文的示例都异常简单。完整的实现应该能够接收任意元的函数，并依调用情况返回恰当的值。</li>
<li><a name="fn:also"></a>柯里化还有很多其它应用，只是本文着重讲述的是柯里化和偏应用的区别，而不是组合子逻辑和函数式编程。</li>
<li><a name="fn:tao"></a>一位道教人士向街边小贩购买一个素食热狗，并说道：“我要全套。”</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure 代码规范]]></title>
    <link href="http://shzhangji.com/blog/2013/01/04/clojure-style-guide/"/>
    <updated>2013-01-04T20:49:00+08:00</updated>
    <id>http://shzhangji.com/blog/2013/01/04/clojure-style-guide</id>
    <content type="html"><![CDATA[<p>原文地址：https://github.com/bbatsov/clojure-style-guide</p>

<p>这份Clojure代码规范旨在提供一系列的最佳实践，让现实工作中的Clojure程序员能够写出易于维护的代码，并能与他人协作和共享。一份反应真实需求的代码规范才能被人接收，而那些理想化的、甚至部分观点遭到程序员拒绝的代码规范注定不会长久——无论它有多出色。</p>

<p>这份规范由多个章节组成，每个章节包含一组相关的规则。我会尝试去描述每条规则背后的理念（过于明显的理念我就省略了）。</p>

<p>这些规则并不是我凭空想象的，它们出自于我作为一个专业软件开发工程师长久以来的工作积累，以及Clojure社区成员们的反馈和建议，还有各种广为流传的Clojure编程学习资源，如<a href="http://www.clojurebook.com/">《Clojure Programming》</a>、<a href="http://joyofclojure.com/">《The Joy of Clojure》</a>等。</p>

<p>这份规范还处于编写阶段，部分章节有所缺失，内容并不完整；部分规则没有示例，或者示例还不能完全将其描述清楚。未来这些问题都会得到改进，只是请你了解这一情况。</p>

<!-- more -->


<p>你可以使用<a href="https://github.com/TechnoGate/transmuter">Transmuter</a>生成一份本规范的PDF或HTML格式的文档。</p>

<h2>目录</h2>

<ul>
<li><a href="#source-code-layout--organization">源代码的布局和组织结构</a></li>
<li><a href="#syntax">语法</a></li>
<li><a href="#naming">命名</a></li>
<li><a href="#comments">注释</a>

<ul>
<li><a href="#comment-annotations">注释中的标识</a></li>
</ul>
</li>
<li><a href="#exceptions">异常</a></li>
<li><a href="#collections">集合</a></li>
<li><a href="#mutation">可变量</a></li>
<li><a href="#strings">字符串</a></li>
<li><a href="#regular-expressions">正则表达式</a></li>
<li><a href="#macros">宏</a></li>
<li><a href="#existential">惯用法</a></li>
</ul>


<h2><a name="source-code-layout--organization"></a>源代码的布局和组织结构</h2>

<blockquote><p>几乎所有人都认为任何代码风格都是丑陋且难以阅读的，除了自己的之外。把这句话中的“除了自己之外”去掉，那差不多就能成立了。
—— Jerry Coffin 关于代码缩进的评论</p></blockquote>

<ul>
<li>使用两个 <strong>空格</strong> 进行缩进，不使用制表符。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(when something
  (something-else))

;; 错误 - 四个空格
(when something
    (something-else))
</code></pre>

<p>```</p>

<ul>
<li>纵向对齐函数参数。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(filter even?
        (range 1 10))

;; 错误
(filter even?
  (range 1 10))
</code></pre>

<p>```</p>

<ul>
<li>对齐let绑定，以及map类型中的关键字。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(let [thing1 "some stuff"
      thing2 "other stuff"]
  {:thing1 thing1
   :thing2 thing2})

;; 错误
(let [thing1 "some stuff"
  thing2 "other stuff"]
  {:thing1 thing1
  :thing2 thing2})
</code></pre>

<p>```</p>

<ul>
<li>当<code>defn</code>没有文档字符串时，可以选择省略函数名和参数列表之间的空行。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn foo
  [x]
  (bar x))

;; 正确
(defn foo [x]
  (bar x))

;; 错误
(defn foo
  [x] (bar x))
</code></pre>

<p>```</p>

<ul>
<li>当函数体较简短时，可以选择忽略参数列表和函数体之间的空行。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn foo [x]
  (bar x))

;; 适合简单的函数
(defn goo [x] (bar x))

;; 适合包含多种参数列表的函数
(defn foo
  ([x] (bar x))
  ([x y]
    (if (predicate? x)
      (bar x)
      (baz x))))

;; 错误
(defn foo
  [x] (if (predicate? x)
        (bar x)
        (baz x)))
</code></pre>

<p>```</p>

<ul>
<li>跨行的文档说明字符串每行都要缩进。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn foo
  "Hello there. This is
  a multi-line docstring."
  []
  (bar))

;; 错误
(defn foo
  "Hello there. This is
a multi-line docstring."
  []
  (bar))
</code></pre>

<p>```
* 使用Unix风格的换行符（*BSD、Solaris、Linux、OSX用户无需设置，Windows用户则需要格外注意了）</p>

<pre><code>* 如果你使用Git，为了防止项目中意外引入Windows风格的换行符，不妨添加如下设置：
</code></pre>

<p>```bash</p>

<pre><code>    $ git config --global core.autocrlf true
</code></pre>

<p>```</p>

<ul>
<li>在括号<code>(</code>、<code>{</code>、<code>[</code>、<code>]</code>、<code>}</code>、<code>)</code>的外部添加空格，括号内部不要添加。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(foo (bar baz) quux)

;; 错误
(foo(bar baz)quux)
(foo ( bar baz ) quux)
</code></pre>

<p>```</p>

<ul>
<li>避免在集合中使用逗号分隔符。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
[1 2 3]
(1 2 3)

;; 错误
[1, 2, 3]
(1, 2, 3)
</code></pre>

<p>```</p>

<ul>
<li>可以考虑在map中适当使用逗号和换行以增强可读性。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
{:name "Bruce Wayne" :alter-ego "Batman"}

;; 正确，且会增强可读性
{:name "Bruce Wayne"
 :alter-ego "Batman"}

;; 正确，且较为紧凑
{:name "Bruce Wayne", :alter-ego "Batman"}
</code></pre>

<p>```</p>

<ul>
<li>将所有的反括号放在一行中。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(when something
  (something-else))

;; 错误
(when something
  (something-else)
)
</code></pre>

<p>```</p>

<ul>
<li>顶层函数之间空出一行。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(def x ...)

(defn foo ...)

;; 错误
(def x ...)
(defn foo ...)
</code></pre>

<p>```</p>

<ul>
<li>函数或宏的定义体中不要添加空行。</li>
<li>每行尽量不超过80个字符。</li>
<li>避免在行末输入多余的空格。</li>
<li>为每个命名空间创建单独的文件。</li>
<li>使用一个完整的<code>ns</code>指令来声明命名空间，其包含<code>import</code>、<code>require</code>、<code>refer</code>、以及<code>use</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>(ns examples.ns
  (:refer-clojure :exclude [next replace remove])
  (:require (clojure [string :as string]
                     [set :as set])
            [clojure.java.shell :as sh])
  (:use (clojure zip xml))
  (:import java.util.Date
           java.text.SimpleDateFormat
           (java.util.concurrent Executors
                                 LinkedBlockingQueue)))
</code></pre>

<p>```</p>

<ul>
<li>避免使用只有一个元素的命名空间名。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(ns example.ns)

;; 错误
(ns example)
</code></pre>

<p>```</p>

<ul>
<li><p>避免使用过长的命名空间（不超过五个元素）。</p></li>
<li><p>一个函数不应超过10行代码。事实上，大多数函数应保持在5行代码以内。</p></li>
<li><p>函数的参数个数不应超过三到四个。</p></li>
</ul>


<h2><a name="syntax"></a>语法</h2>

<ul>
<li>避免使用<code>require</code>、<code>refer</code>等改变命名空间的函数，它们只应在REPL中使用。</li>
<li>使用<code>declare</code>实现引用传递。</li>
<li><p>优先使用<code>map</code>这类高阶函数，而非<code>loop/recur</code>。</p></li>
<li><p>优先使用前置、后置条件来检测函数参数和返回值：</p></li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn foo [x]
  {:pre [(pos? x)]}
  (bar x))

;; 错误
(defn foo [x]
  (if (pos? x)
    (bar x)
    (throw (IllegalArgumentException "x must be a positive number!")))
</code></pre>

<p>```</p>

<ul>
<li>不要在函数中定义变量：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 非常糟糕
(defn foo []
  (def x 5)
  ...)
</code></pre>

<p>```</p>

<ul>
<li>本地变量名不应覆盖<code>clojure.core</code>中定义的函数：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 错误——这样一来函数中调用`map`时就需要指定完整的命名空间了。
(defn foo [map]
  ...)
</code></pre>

<p>```</p>

<ul>
<li>使用<code>seq</code>来判断一个序列是否为空（空序列等价于nil）。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; 错误
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>when</code>替代<code>(if ... (do ...)</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(when pred
  (foo)
  (bar))

;; 错误
(if pred
  (do
    (foo)
    (bar)))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>if-let</code>替代<code>let</code> + <code>if</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(if-let [result :foo]
  (something-with result)
  (something-else))

;; 错误
(let [result :foo]
  (if result
    (something-with result)
    (something-else)))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>when-let</code>替代<code>let</code> + <code>when</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(when-let [result :foo]
  (do-something-with result)
  (do-something-more-with result))

;; 错误
(let [result :foo]
  (when result
    (do-something-with result)
    (do-something-more-with result)))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>if-not</code>替代<code>(if (not ...) ...)</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(if-not (pred)
  (foo))

;; 错误
(if (not pred)
  (foo))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>when-not</code>替代<code>(when (not ...) ...)</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(when-not pred
  (foo)
  (bar))

;; 错误
(when (not pred)
  (foo)
  (bar))
</code></pre>

<p>```</p>

<ul>
<li>使用<code>not=</code>替代<code>(not (= ...))</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(not= foo bar)

;; 错误
(not (= foo bar))
</code></pre>

<p>```</p>

<ul>
<li>当匿名函数只有一个参数时，优先使用<code>%</code>，而非<code>%1</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
#(Math/round %)

;; 错误
#(Math/round %1)
</code></pre>

<p>```</p>

<ul>
<li>当匿名函数有多个参数时，优先使用<code>%1</code>，而非<code>%</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
#(Math/pow %1 %2)

;; 错误
#(Math/pow % %2)
</code></pre>

<p>```</p>

<ul>
<li>只有在必要的时候才使用匿名函数。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(filter even? (range 1 10))

;; 错误
(filter #(even? %) (range 1 10))
</code></pre>

<p>```</p>

<ul>
<li>当匿名函数包含多行语句时，使用<code>fn</code>来定义，而非<code>#(do ...)</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(fn [x]
  (println x)
  (* x 2))

;; 错误（你不得不使用`do`）
#(do (println %)
     (* % 2))
</code></pre>

<p>```</p>

<ul>
<li>在特定情况下优先使用<code>complement</code>，而非匿名函数。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(filter (complement some-pred?) coll)

;; 错误
(filter #(not (some-pred? %)) coll)
</code></pre>

<p>```</p>

<p>当函数已存在对应的求反函数时，则应使用该求反函数（如<code>even?</code>和<code>odd?</code>）。</p>

<ul>
<li>某些情况下可以用<code>comp</code>使代码更简洁。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(map #(capitalize (trim %)) ["top " " test "])

;; 更好
(map (comp capitalize trim) ["top " " test "])
</code></pre>

<p>```</p>

<ul>
<li>某些情况下可以用<code>partial</code>使代码更简洁。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(map #(+ 5 %) (range 1 10))

;; 或许更好
(map (partial + 5) (range 1 10))
</code></pre>

<p>```</p>

<ul>
<li>当遇到嵌套调用时，建议使用<code>-&gt;</code>宏和<code>-&gt;&gt;</code>宏。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(-&gt; [1 2 3]
    reverse
    (conj 4)
    prn)

;; 不够好
(prn (conj (reverse [1 2 3])
           4))

;; 正确
(-&gt;&gt; (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; 不够好
(map (partial * 2)
     (filter even? (range 1 10)))
</code></pre>

<p>```</p>

<ul>
<li>当需要连续调用Java类的方法时，优先使用<code>..</code>，而非<code>-&gt;</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(-&gt; (System/getProperties) (.get "os.name"))

;; 更好
(.. System getProperties (get "os.name"))
</code></pre>

<p>```</p>

<ul>
<li>在<code>cond</code>和<code>condp</code>中，使用<code>:else</code>来处理不满足条件的情况。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(cond
  (&lt; n 0) "negative"
  (&gt; n 0) "positive"
  :else "zero"))

;; 错误
(cond
  (&lt; n 0) "negative"
  (&gt; n 0) "positive"
  true "zero"))
</code></pre>

<p>```</p>

<ul>
<li>当比较的变量和方式相同时，优先使用<code>condp</code>，而非<code>cond</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :forty
  :else :dunno)

;; 更好
(condp = x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)
</code></pre>

<p>```</p>

<ul>
<li>当条件是常量时，优先使用<code>case</code>，而非<code>cond</code>或<code>condp</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :forty
  :else :dunno)

;; 更好
(condp = x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; 最佳
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)
</code></pre>

<p>```</p>

<ul>
<li>某些情况下，使用<code>set</code>作为判断条件。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 错误
(remove #(= % 0) [0 1 2 3 4 5])

;; 正确
(remove #{0} [0 1 2 3 4 5])

;; 错误
(count (filter #(or (= % \a)
                    (= % \e)
                    (= % \i)
                    (= % \o)
                    (= % \u))
               "mary had a little lamb"))

;; 正确
(count (filter #{\a \e \i \o \u} "mary had a little lamb"))
</code></pre>

<p>```</p>

<ul>
<li><p>使用<code>(inc x)</code>和<code>(dec x)</code>替代<code>(+ x 1)</code>和<code>(- x 1)</code>。</p></li>
<li><p>使用<code>(pos? x)</code>、<code>(neg? x)</code>、以及<code>(zero? x)</code>替代<code>(&gt; x 0)</code>、<code>(&lt; x 0)</code>、和<code>(= x 0)</code>。</p></li>
<li><p>进行Java操作时，优先使用Clojure提供的语法糖。</p></li>
</ul>


<p>```clojure</p>

<pre><code>;;; 创建对象
;; 正确
(java.util.ArrayList. 100)

;; 错误
(new java.util.ArrayList 100)

;;; 调用静态方法
;; 正确
(Math/pow 2 10)

;; 错误
(. Math pow 2 10)

;;; 调用实例方法
;; 正确
(.substring "hello" 1 3)

;; 错误
(. "hello" substring 1 3)

;;; 访问静态属性
;; 正确
Integer/MAX_VALUE

;; 错误
(. Integer MAX_VALUE)

;;; 访问实例属性
;; 正确
(.someField some-object)

;; 错误
(. some-object some-field)
</code></pre>

<p>```</p>

<h2><a name="naming"></a>命名</h2>

<blockquote><p>编程中真正的难点只有两个：验证缓存的有效性；命名。<br/>
—— Phil Karlton</p></blockquote>

<ul>
<li>命名空间建议使用以下两种方式：

<ul>
<li><code>项目名称.模块名称</code></li>
<li><code>组织名称.项目名称.模块名称</code></li>
</ul>
</li>
<li>对于命名空间中较长的元素，使用<code>lisp-case</code>格式，如<code>bruce.project-euler</code>。</li>
<li>使用<code>lisp-case</code>格式来命名函数和变量。</li>
<li>使用<code>CamelCase</code>来命名接口（protocol）、记录（record）、结构和类型（struct &amp; type）。对于HTTP、RFC、XML等缩写，仍保留其大写格式。</li>
<li>对于返回布尔值的函数名称，使用问号结尾，如<code>even?</code>。</li>
<li>当方法或宏不能在STM中安全使用时，须以感叹号结尾，如<code>reset!</code>。</li>
<li>命名类型转换函数时使用<code>-&gt;</code>，而非<code>to</code>。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(defn f-&gt;c ...)

;; 不够好
(defn f-to-c ...)
</code></pre>

<p>```</p>

<ul>
<li>对于可供重绑定的变量（即动态变量），使用星号括起，如<code>*earmuffs*</code>。</li>
<li>无需对常量名进行特殊的标识，因为所有的变量都应该是常量，除非有特别说明。</li>
<li>对于解构过程中或参数列表中忽略的元素，使用<code>_</code>来表示。</li>
<li>参考<code>clojure.core</code>中的命名规范，如<code>pred</code>、<code>coll</code>：

<ul>
<li>函数：

<ul>
<li><code>f</code>、<code>g</code>、<code>h</code>：参数内容是一个函数</li>
<li><code>n</code>：整数，通常是一个表示大小的值</li>
<li><code>index</code>：整数索引</li>
<li><code>x</code>、<code>y</code>：数值</li>
<li><code>s</code>：字符串</li>
<li><code>coll</code>：集合</li>
<li><code>pred</code>：断言型的闭包</li>
<li><code>&amp; more</code>：可变参数</li>
</ul>
</li>
<li>宏：

<ul>
<li><code>expr</code>：表达式</li>
<li><code>body</code>：语句</li>
<li><code>binding</code>：一个向量，包含宏的绑定</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2><a name="collections"></a>集合</h2>

<blockquote><p>用100种函数去操作同一种数据结构，要好过用10种函数操作10种数据结构。<br/>
—— Alan J. Perlis</p></blockquote>

<ul>
<li>避免使用列表（list）来存储数据（除非它真的就是你想要的）。</li>
<li>优先使用关键字（keyword），而非普通的哈希键：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
{:name "Bruce" :age 30}

;; 错误
{"name" "Bruce" "age" 30}
</code></pre>

<p>```</p>

<ul>
<li>编写集合时，优先使用内置的语法形式，而非构造函数。但是，在定义唯一值集合（set）时，只有当元素都是常量时才可使用内置语法，否则应使用构造函数，如下所示：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
[1 2 3]
#{1 2 3}
(hash-set (func1) (func2)) ; 元素在运行时确定

;; bad
(vector 1 2 3)
(hash-set 1 2 3)
#{(func1) (func2)} ; 若(func1)和(func2)的值相等，则会抛出运行时异常。
</code></pre>

<p>```</p>

<ul>
<li><p>避免使用数值索引来访问集合元素。</p></li>
<li><p>优先使用关键字来获取哈希表（map）中的值。</p></li>
</ul>


<p>```clojure</p>

<pre><code>(def m {:name "Bruce" :age 30})

;; 正确
(:name m)

;; 错误——太过啰嗦
(get m :name)

;; 错误——可能抛出空指针异常
(m :name)
</code></pre>

<p>```</p>

<ul>
<li>集合可以被用作函数：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(filter #{\a \e \o \i \u} "this is a test")

;; 缺点——不够美观
</code></pre>

<p>```</p>

<ul>
<li>关键字可以被用作函数：</li>
</ul>


<p>```clojure</p>

<pre><code>((juxt :a :b) {:a "ala" :b "bala"})
</code></pre>

<p>```</p>

<ul>
<li><p>只有在非常强调性能的情况下才可使用瞬时集合（transient collection）。</p></li>
<li><p>避免使用Java集合。</p></li>
<li><p>避免使用Java数组，除非遇到需要和Java类进行交互，或需要高性能地处理基本类型时才可使用。</p></li>
</ul>


<h2><a name="mutation"></a>可变量</h2>

<h3>引用（Refs）</h3>

<ul>
<li>建议所有的IO操作都使用<code>io!</code>宏进行包装，以免不小心在事务中调用了这些代码。</li>
<li>避免使用<code>ref-set</code>。</li>
<li>控制事务的大小，即事务所执行的工作越少越好。</li>
<li>避免出现短期事务和长期事务访问同一个引用（Ref）的情形。</li>
</ul>


<h3>代理（Agents）</h3>

<ul>
<li><code>send</code>仅使用于计算密集型、不会因IO等因素阻塞的线程。</li>
<li><code>send-off</code>则用于会阻塞、休眠的线程。</li>
</ul>


<h3>原子（Atoms）</h3>

<ul>
<li>避免在事务中更新原子。</li>
<li>避免使用<code>reset!</code>。</li>
</ul>


<h2><a name="strings"></a>字符串</h2>

<ul>
<li>优先使用<code>clojure.string</code>中提供的字符串操作函数，而不是Java中提供的或是自己编写的函数。</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(clojure.string/upper-case "bruce")

;; 错误
(.toUpperCase "bruce")
</code></pre>

<p>```</p>

<h2><a name="exceptions"></a>异常</h2>

<ul>
<li>复用已有的异常类型，如：

<ul>
<li><code>java.lang.IllegalArgumentException</code></li>
<li><code>java.lang.UnsupportedOperationException</code></li>
<li><code>java.lang.IllegalStateException</code></li>
<li><code>java.io.IOException</code></li>
</ul>
</li>
<li>优先使用<code>with-open</code>，而非<code>finally</code>。</li>
</ul>


<h2><a name="macros"></a>宏</h2>

<ul>
<li>如果可以用函数实现相同功能，不要编写一个宏。</li>
<li>首先编写一个宏的用例，尔后再编写宏本身。</li>
<li>尽可能将一个复杂的宏拆解为多个小型的函数。</li>
<li>宏只应用于简化语法，其核心应该是一个普通的函数。</li>
<li>使用语法转义（syntax-quote，即反引号），而非手动构造<code>list</code>。</li>
</ul>


<h2><a name="comments"></a>注释</h2>

<blockquote><p>好的代码本身就是文档。因此在添加注释之前，先想想自己该如何改进代码，让它更容易理解。做到这一点后，再通过注释让代码更清晰。<br/>
——Steve McConnel</p></blockquote>

<ul>
<li><p>学会编写容易理解的代码，然后忽略下文的内容。真的！</p></li>
<li><p>对于标题型的注释，使用至少四个分号起始。</p></li>
<li><p>对于顶层注释，使用三个分号起始。</p></li>
<li><p>为某段代码添加注释时，使用两个分号起始，且应与该段代码对齐。</p></li>
<li><p>对于行尾注释，使用一个分号起始即可。</p></li>
<li><p>分号后面要有一个空格。</p></li>
</ul>


<p>```clojure</p>

<pre><code>;;;; Frob Grovel

;;; 这段代码有以下前提：
;;;   1. Foo.
;;;   2. Bar.
;;;   3. Baz.

(defn fnord [zarquon]
  ;; If zob, then veeblefitz.
  (quux zot
        mumble             ; Zibblefrotz.
        frotz))
</code></pre>

<p>```</p>

<ul>
<li>对于成句的注释，句首字母应该大写，<a href="http://en.wikipedia.org/wiki/Sentence_spacing">句与句之间用一个空格分隔</a>。</li>
<li>避免冗余的注释：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 错误
(inc counter) ; counter变量的值加1
</code></pre>

<p>```</p>

<ul>
<li>注释要和代码同步更新。过期的注释还不如没有注释。</li>
<li>有时，使用<code>#_</code>宏要优于普通的注释：</li>
</ul>


<p>```clojure</p>

<pre><code>;; 正确
(+ foo #_(bar x) delta)

;; 错误
(+ foo
   ;; (bar x)
   delta)
</code></pre>

<p>```</p>

<blockquote><p>好的代码和好的笑话一样，不需要额外的解释。
——Russ Olsen</p></blockquote>

<ul>
<li>避免使用注释去描述一段写得很糟糕的代码。重构它，让它更为可读。（做或者不做，没有尝试这一说。——Yoda）</li>
</ul>


<h3><a name="comment-annotations"></a>注释中的标识</h3>

<ul>
<li>标识应该写在对应代码的上一行。</li>
<li>标识后面是一个冒号和一个空格，以及一段描述文字。</li>
<li>如果标识的描述文字超过一行，则第二行需要进行缩进。</li>
<li>将自己姓名的首字母以及当前日期附加到标识描述文字中：</li>
</ul>


<p>```clojure</p>

<pre><code>(defn some-fun
  []
  ;; FIXME: 这段代码在v1.2.3之后偶尔会崩溃，
  ;;        这可能和升级BarBazUtil有关。（xz 13-1-31）
  (baz))
</code></pre>

<p>```</p>

<ul>
<li>对于功能非常明显，实在无需添加注释的情况，可以在行尾添加一个标识：</li>
</ul>


<p>```clojure</p>

<pre><code>(defn bar
  []
  (sleep 100)) ; OPTIMIZE
</code></pre>

<p>```</p>

<ul>
<li>使用<code>TODO</code>来表示需要后期添加的功能或特性。</li>
<li>使用<code>FIXME</code>来表示需要修复的问题。</li>
<li>使用<code>OPTIMIZE</code>来表示会引起性能问题的代码，并需要修复。</li>
<li>使用<code>HACK</code>来表示这段代码并不正规，需要在后期进行重构。</li>
<li>使用<code>REVIEW</code>来表示需要进一步审查这段代码，如：<code>REVIEW: 你确定客户会正确地操作X吗？</code></li>
<li>可以使用其它你认为合适的标识关键字，但记得一定要在项目的<code>README</code>文件中描述这些自定义的标识。</li>
</ul>


<h2><a name="existential"></a>惯用法</h2>

<ul>
<li>使用函数式风格进行编程，避免改变变量的值。</li>
<li>保持编码风格。</li>
<li>用正常人的思维来思考。</li>
</ul>


<h1>贡献</h1>

<p>本文中的所有内容都还没有最后定型，我很希望能够和所有对Clojure代码规范感兴趣的同仁一起编写此文，从而形成一份对社区有益的文档。</p>

<p>你可以随时创建讨论话题，或发送合并申请。我在这里提前表示感谢。</p>

<h1>宣传</h1>

<p>一份由社区驱动的代码规范如果得不到社区本身的支持和认同，那它就毫无意义了。发送一条推特，向朋友和同事介绍此文。任何评论、建议、以及意见都能够让我们向前迈进一小步。请让我们共同努力吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开源软件架构 - 卷1：第14章 Python打包工具]]></title>
    <link href="http://shzhangji.com/blog/2012/11/18/aosa-python-packaging/"/>
    <updated>2012-11-18T19:20:00+08:00</updated>
    <id>http://shzhangji.com/blog/2012/11/18/aosa-python-packaging</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://www.aosabook.org/en/intro1.html#ziade-tarek">Tarek Ziadé</a>，翻译：<a href="mailto:zhangji87@gmail.com">张吉</a></p>

<p>原文：<a href="http://www.aosabook.org/en/packaging.html">http://www.aosabook.org/en/packaging.html</a></p>

<h2>14.1 简介</h2>

<p>对于如何安装软件，目前有两种思想流派。第一种是说软件应该自给自足，不依赖于其它任何部件，这点在Windows和Mac OS X系统中很流行。这种方式简化了软件的管理：每个软件都有自己独立的“领域”，安装和卸载它们不会对操作系统产生影响。如果软件依赖一项不常见的类库，那么这个类库一定是包含在软件安装包之中的。</p>

<p>第二种流派，主要在类Linux的操作系统中盛行，即软件应该是由一个个独立的、小型的软件包组成的。类库被包含在软件包中，包与包之间可以有依赖关系。安装软件时需要查找和安装它所依赖的其他特定版本的软件包。这些依赖包通常是从一个包含所有软件包的中央仓库中获取的。这种理念也催生了Linux发行版中那些复杂的依赖管理工具，如<code>dpkg</code>和<code>RPM</code>。它们会跟踪软件包的依赖关系，并防止两个软件使用了版本相冲突的第三方包。</p>

<p>以上两种流派各有优劣。高度模块化的系统可以使得更新和替换某个软件包变的非常方便，因为每个类库都只有一份，所有依赖于它的应用程序都能因此受益。比如，修复某个类库的安全漏洞可以立刻应用到所有程序中，而如果应用程序使用了自带的类库，那安全更新就很难应用进去了，特别是在类库版本不一致的情况下更难处理。</p>

<p>不过这种“模块化”也被一些开发者视为缺点，因为他们无法控制应用程序的依赖关系。他们希望提供一个独立和稳定的软件运行环境，这样就不会在系统升级后遭遇各种依赖方面的问题。</p>

<!-- more -->


<p>在安装程序中包含所有依赖包还有一个优点：便于跨平台。有些项目在这点上做到了极致，它们将所有和操作系统的交互都封装了起来，在一个独立的目录中运行，甚至包括日志文件的记录位置。</p>

<p>Python的打包系统使用的是第二种设计思想，并尽可能地方便开发者、管理员、用户对软件的管理。不幸的是，这种方式导致了种种问题：错综复杂的版本结构、混乱的数据文件、难以重新打包等等。三年前，我和其他一些Python开发者决定研究解决这个问题，我们自称为“打包别动队”，本文就是讲述我们在这个问题上做出的努力和取得的成果。</p>

<h3>术语</h3>

<p>在Python中， <em>包</em> 表示一个包含Python文件的目录。Python文件被称为 <em>模块</em> ，这样一来，使用“包”这个单词就显得有些模糊了，因为它常常用来表示某个项目的 <em>发行版本</em> 。</p>

<p>Python开发者有时也对此表示不能理解。为了更清晰地进行表述，我们用“Python包（package）”来表示一个包含Python文件的目录，用“发行版本（release）”来表示某个项目的特定版本，用“发布包（distribution）”来表示某个发行版本的源码或二进制文件，通常是Tar包或Zip文件的形式。</p>

<h2>14.2 Python开发者的困境</h2>

<p>大多数Python开发者希望自己的程序能够在任何环境中运行。他们还希望自己的软件既能使用标准的Python类库，又能使用依赖于特定系统类型的类库。但除非开发者使用现有的各种打包工具生成不同的软件包，否则他们打出的软件安装包就必须在一个安装有Python环境的系统中运行。这样的软件包还希望做到以下几点：</p>

<ul>
<li>其他人可以针对不同的目标系统对这个软件重新打包；</li>
<li>软件所依赖的包也能够针对不同的目标系统进行重新打包；</li>
<li>系统依赖项能够被清晰地描述出来。</li>
</ul>


<p>要做到以上几点往往是不可能的。举例来说，Plone这一功能全面的CMS系统，使用了上百个纯Python语言编写的类库，而这些类库并不一定在所有的打包系统中提供。这就意味着Plone必须将它所依赖的软件包都集成到自己的安装包中。要做到这一点，他们选择使用<code>zc.buildout</code>这一工具，它能够将所有的依赖包都收集起来，生成一个完整的应用程序文件，在独立的目录中运行。它事实上是一个二进制的软件包，因为所有C语言代码都已经编译好了。</p>

<p>这对开发者来说是福音：他们只需要描述好依赖关系，然后借助<code>zc.buildout</code>来发布自己的程序即可。但正如上文所言，这种发布方式在系统层面构筑了一层屏障，这让大多数Linux系统管理员非常恼火。Windows管理员不会在乎这些，但CentOS和Debian管理员则会，因为按照他们的管理原则，系统中的所有文件都应该被注册和归类到现有的管理工具中。</p>

<p>这些管理员会想要将你的软件按照他们自己的标准重新打包。问题在于：Python有没有这样的打包工具，能够自动地按照新的标准重新打包？如果有，那么Python的任何软件和类库就能够针对不同的目标系统进行打包，而不需要额外的工作。这里，“自动”一词并不是说打包过程可以完全由脚本来完成——这点上<code>RPM</code>和<code>dpkg</code>的使用者已经证实是不可能的了，因为他们总会需要增加额外的信息来重新打包。他们还会告诉你，在重新打包的过程中会遇到一些开发者没有遵守基本打包原则的情况。</p>

<p>我们来举一个实际例子，如何通过使用现有的Python打包工具来惹恼那些想要重新打包的管理员：在发布一个名为“MathUtils”的软件包时使用“Fumanchu”这样的版本号名字。撰写这个类库的数学家想用自家猫咪的名字来作为版本号，但是管理员怎么可能知道“Fumanchu”是他家第二只猫的名字，第一只猫叫做“Phil”，所以“Fumanchu”版本要比“Phil”版本来得高？</p>

<p>可能这个例子有些极端，但是在现有的打包工具和规范中是可能发生的。最坏的情况是<code>easy_install</code>和<code>pip</code>使用自己的一套标准来追踪已安装的文件，并使用字母顺序来比较“Fumanchu”和“Phil”的版本高低。</p>

<p>另一个问题是如何处理数据文件。比如，如果你的软件使用了SQLite数据库，安装时被放置在包目录中，那么在程序运行时，系统会阻止你对其进行读写操作。这样做还会破坏Linux系统的一项惯例，即<code>/var</code>目录下的数据文件是需要进行备份的。</p>

<p>在现实环境中，系统管理员需要能够将你的文件放置到他们想要的地方，并且不破坏程序的完整性，这就需要你来告诉他们各类文件都是做什么用的。让我们换一种方式来表述刚才的问题：Python是否有这样一种打包工具，它可以提供各类信息，足以让第三方打包工具能据此重新进行打包，而不需要阅读软件的源码？</p>

<h2>14.3 现有的打包管理架构</h2>

<p>Python标准库中提供的<code>Distutils</code>打包工具充斥了上述的种种问题，但由于它是一种标准，所以人们要么继续忍受并使用它，或者转向更先进的工具<code>Setuptools</code>，它在Distutils之上提供了一些高级特性。另外还有<code>Distribute</code>，它是<code>Setuptools</code>的衍生版本。<code>Pip</code>则是一种更为高级的安装工具，它依赖于<code>Setuptools</code>。</p>

<p>但是，这些工具都源自于<code>Distutils</code>，并继承了它的种种问题。有人也想过要改进<code>Distutils</code>本身，但是由于它的使用范围已经很广很广，任何小的改动都会对Python软件包的整个生态系统造成冲击。</p>

<p>所以，我们决定冻结<code>Distutils</code>的代码，并开始研发<code>Distutils2</code>，不去考虑向前兼容的问题。为了解释我们所做的改动，首先让我们近距离观察一下<code>Distutils</code>。</p>

<h3>14.3.1 Distutils基础及设计缺陷</h3>

<p><code>Distutils</code>由一些命令组成，每条命令都是一个包含了<code>run</code>方法的类，可以附加若干参数进行调用。<code>Distutils</code>还提供了一个名为<code>Distribution</code>的类，它包含了一些全局变量，可供其他命令使用。</p>

<p>当要使用<code>Distutils</code>时，Python开发者需要在项目中添加一个模块，通常命名为<code>setup.py</code>。这个模块会调用<code>Distutils</code>的入口函数：<code>setup</code>。这个函数有很多参数，这些参数会被<code>Distribution</code>实例保存起来，供后续使用。下面这个例子中我们指定了一些常用的参数，如项目名称和版本，它所包含的模块等：</p>

<p>```python
from distutils.core import setup</p>

<p>setup(name='MyProject', version='1.0', py_modules=['mycode.py'])
```</p>

<p>这个模块可以用来执行<code>Distutils</code>的各种命令，如<code>sdist</code>。这条命令会在<code>dist</code>目录中创建一个源代码发布包：</p>

<p><code>bash
$ python setup.py sdist
</code></p>

<p>这个模块还可以执行<code>install</code>命令：</p>

<p><code>bash
$ python setup.py install
</code></p>

<p><code>Distutils</code>还提供了一些其他命令：</p>

<ul>
<li><code>upload</code> 将发布包上传至在线仓库</li>
<li><code>register</code> 向在线仓库注册项目的基本信息，而不上传发布包</li>
<li><code>bdist</code> 创建二进制发布包</li>
<li><code>bdist_msi</code> 创建<code>.msi</code>安装包，供Windows系统使用</li>
</ul>


<p>我们还可以使用其他一些命令来获取项目的基本信息。</p>

<p>所以在安装或获取应用程序信息时都是通过这个文件调用<code>Distutils</code>实现的，如获取项目名称：</p>

<p><code>bash
$ python setup.py --name
MyProject
</code></p>

<p><code>setup.py</code>是一个项目的入口，可以通过它对项目进行构建、打包、发布、安装等操作。开发者通过这个函数的参数信息来描述自己的项目，并使用它进行各种打包任务。这个文件同样用于在目标系统中安装软件。</p>

<p><img src="http://www.aosabook.org/images/packaging/setup-py.png" alt="图14.1 安装" /></p>

<p>图14.1 安装</p>

<p>然而，使用同一个文件来对项目进行打包、发布、以及安装，是<code>Distutils</code>的主要缺点。例如，你需要查看<code>lxml</code>项目的名称属性，<code>setup.py</code>会执行很多其他无关的操作，而不是简单返回一个字符串：</p>

<p><code>bash
$ python setup.py --name
Building lxml version 2.2.
NOTE: Trying to build without Cython, pre-generated 'src/lxml/lxml.etree.c'
needs to be available.
Using build configuration of libxslt 1.1.26
Building against libxml2/libxslt in the following directory: /usr/lib/lxml
</code></p>

<p>在有些项目中它甚至会执行失败，因为开发者默认为<code>setup.py</code>只是用来安装软件的，而其他一些<code>Distutils</code>功能只在开发过程中使用。因此，<code>setup.py</code>的角色太多，容易引起他人的困惑。</p>

<h3>14.3.2 元信息和PyPI</h3>

<p><code>Distutils</code>在构建发布包时会创建一个<code>Metadata</code>文件。这个文件是按照PEP314<sup>1</sup>编写的，包含了一些常见的项目信息，包括名称、版本等，主要有以下几项：</p>

<ul>
<li><code>Name</code>：项目名称</li>
<li><code>Version</code>：发布版本号</li>
<li><code>Summary</code>：项目简介</li>
<li><code>Description</code>：项目详情</li>
<li><code>Home-Page</code>：项目主页</li>
<li><code>Author</code>：作者</li>
<li><code>Classifers</code>：项目类别。Python为不同的发行协议、发布版本（beta，alpha，final）等提供了不同的类别。</li>
<li><code>Requires</code>，<code>Provides</code>，<code>Obsoletes</code>：描述项目依赖信息</li>
</ul>


<p>这些信息一般都能移植到其他打包系统中。</p>

<p>Python项目索引（Python Package Index，简称PyPI<sup>2</sup>），是一个类似CPAN的中央软件包仓库，可以调用<code>Distutils</code>的<code>register</code>和<code>upload</code>命令来注册和发布项目。<code>register</code>命令会构建<code>Metadata</code>文件并传送给PyPI，让访问者和安装工具能够浏览和搜索。</p>

<p><img src="http://www.aosabook.org/images/packaging/pypi.png" alt="图14.2：PyPI仓库" /></p>

<p>图14.2：PyPI仓库</p>

<p>你可以通过<code>Classifies</code>（类别）来浏览，获取项目作者的名字和主页。同时，<code>Requires</code>可以用来定义Python模块的依赖关系。<code>requires</code>选项可以向元信息文件的<code>Requires</code>字段添加信息：</p>

<p>```python
from distutils.core import setup</p>

<p>setup(name='foo', version='1.0', requires=['ldap'])
```</p>

<p>这里声明了对<code>ldap</code>模块的依赖，这种依赖并没有实际效力，因为没有安装工具会保证这个模块真实存在。如果说Python代码中会使用类似Perl的<code>require</code>关键字来定义依赖关系，那还有些作用，因为这时安装工具会检索PyPI上的信息并进行安装，其实这也就是CPAN的做法。但是对于Python来说，<code>ldap</code>模块可以存在于任何项目之中，因为<code>Distutils</code>是允许开发者发布一个包含多个模块的软件的，所以这里的元信息字段并无太大作用。</p>

<p><code>Metadata</code>的另一个缺点是，因为它是由Python脚本创建的，所以会根据脚本执行环境的不同而产生特定信息。比如，运行在Windows环境下的一个项目会在<code>setup.py</code>文件中有以下描述：</p>

<p>```python
from distutils.core import setup</p>

<p>setup(name='foo', version='1.0', requires=['win32com'])
```</p>

<p>这样配置相当于是默认该项目只会运行在Windows环境下，即使它可能提供了跨平台的方案。一种解决方法是根据不同的平台来指定<code>requires</code>参数：</p>

<p>```python
from distutils.core import setup
import sys</p>

<p>if sys.platform == 'win32':</p>

<pre><code>setup(name='foo', version='1.0', requires=['win32com'])
</code></pre>

<p>else:</p>

<pre><code>setup(name='foo', version='1.0')
</code></pre>

<p>```</p>

<p>但这种做法往往会让事情更糟。要注意，这个脚本是用来将项目的源码包发布到PyPI上的，这样写就说明它向PyPI上传的<code>Metadata</code>文件会因为该脚本运行环境的不同而不同。换句话说，这使得我们无法在元信息文件中看出这个项目依赖于特定的平台。</p>

<h3>14.3.3 PyPI的架构设计</h3>

<p><img src="http://www.aosabook.org/images/packaging/pypi-workflow.png" alt="图14.3 PyPI工作流" /></p>

<p>图14.3 PyPI工作流</p>

<p>如上文所述，PyPI是一个Python项目的中央仓库，人们可以通过不同的类别来搜索已有的项目，也可以创建自己的项目。人们可以上传项目源码和二进制文件，供其他人下载使用或研究。同时，PyPI还提供了相应的Web服务，让安装工具可以调用它来检索和下载文件。</p>

<h4>注册项目并上传发布包</h4>

<p>我们可以使用<code>Distutils</code>的<code>register</code>命令在PyPI中注册一个项目。这个命令会根据项目的元信息生成一个POST请求。该请求会包含验证信息，PyPI使用HTTP基本验证来确保所有的项目都和一个注册用户相关联。验证信息保存在<code>Distutils</code>的配置文件中，或在每次执行<code>register</code>命令时提示用户输入。以下是一个使用示例：</p>

<p><code>bash
$ python setup.py register
running register
Registering MPTools to http://pypi.python.org/pypi
Server response (200): OK
</code></p>

<p>每个注册项目都会产生一个HTML页面，上面包含了它的元信息。开发者可以使用<code>upload</code>命令将发布包上传至PyPI：</p>

<p><code>bash
$ python setup.py sdist upload
running sdist
…
running upload
Submitting dist/mopytools-0.1.tar.gz to http://pypi.python.org/pypi
Server response (200): OK
</code></p>

<p>如果开发者不想将代码上传至PyPI，可以使用元信息中的<code>Download-URL</code>属性来指定一个外部链接，供用户下载。</p>

<h4>检索PyPI</h4>

<p>除了在页面中检索项目，PyPI还提供了两个接口供程序调用：简单索引协议和XML-PRC API。</p>

<p>简单索引协议的地址是<code>http://pypi.python.org/simple/</code>，它包含了一个链接列表，指向所有的注册项目：</p>

<p><code>html
&lt;html&gt;&lt;head&gt;&lt;title&gt;Simple Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
⋮    ⋮    ⋮
&lt;a href='MontyLingua/'&gt;MontyLingua&lt;/a&gt;&lt;br/&gt;
&lt;a href='mootiro_web/'&gt;mootiro_web&lt;/a&gt;&lt;br/&gt;
&lt;a href='Mopidy/'&gt;Mopidy&lt;/a&gt;&lt;br/&gt;
&lt;a href='mopowg/'&gt;mopowg&lt;/a&gt;&lt;br/&gt;
&lt;a href='MOPPY/'&gt;MOPPY&lt;/a&gt;&lt;br/&gt;
&lt;a href='MPTools/'&gt;MPTools&lt;/a&gt;&lt;br/&gt;
&lt;a href='morbid/'&gt;morbid&lt;/a&gt;&lt;br/&gt;
&lt;a href='Morelia/'&gt;Morelia&lt;/a&gt;&lt;br/&gt;
&lt;a href='morse/'&gt;morse&lt;/a&gt;&lt;br/&gt;
⋮    ⋮    ⋮
&lt;/body&gt;&lt;/html&gt;
</code></p>

<p>如MPTools项目对应的<code>MPTools/</code>目录，它所指向的路径会包含以下内容：</p>

<ul>
<li>所有发布包的地址</li>
<li>在<code>Metadata</code>中定义的项目网站地址，包含所有版本</li>
<li>下载地址（<code>Download-URL</code>），同样包含所有版本</li>
</ul>


<p>以MPTools项目为例：</p>

<p><code>html
&lt;html&gt;&lt;head&gt;&lt;title&gt;Links for MPTools&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;h1&gt;Links for MPTools&lt;/h1&gt;
&lt;a href="../../packages/source/M/MPTools/MPTools-0.1.tar.gz"&gt;MPTools-0.1.tar.gz&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://bitbucket.org/tarek/mopytools" rel="homepage"&gt;0.1 home_page&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;&lt;/html&gt;
</code></p>

<p>安装工具可以通过访问这个索引来查找项目的发布包，或者检查<code>http://pypi.python.org/simple/PROJECT_NAME/</code>是否存在。</p>

<p>但是，这个协议主要有两个缺陷。首先，PyPI目前还是单台服务器。虽然很多用户会自己搭建镜像，但过去两年中曾发生过几次PyPI无法访问的情况，用户无法下载依赖包，导致项目构建出现问题。比如说，在构建一个Plone项目时，需要向PyPI发送近百次请求。所以PyPI在这里成为了单点故障。</p>

<p>其次，当项目的发布包没有保存在PyPI中，而是通过<code>Download-URL</code>指向了其他地址，安装工具就需要重定向到这个地址下载发布包。这种情况也会增加安装过程的不稳定性。</p>

<p>简单索引协议只是提供给安装工具一个项目列表，并不包含项目元信息。可以通过PyPI的XML-RPC API来获取项目元信息：</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>import xmlrpclib
import pprint
client = xmlrpclib.ServerProxy('http://pypi.python.org/pypi')
client.package_releases('MPTools')
['0.1']
pprint.pprint(client.release_urls('MPTools', '0.1'))
[{'comment_text': &rquot;,
'downloads': 28,
'filename': 'MPTools-0.1.tar.gz',
'has_sig': False,
'md5_digest': '6b06752d62c4bffe1fb65cd5c9b7111a',
'packagetype': 'sdist',
'python_version': 'source',
'size': 3684,
'upload_time': <DateTime '20110204T09:37:12' at f4da28>,
'url': 'http://pypi.python.org/packages/source/M/MPTools/MPTools-0.1.tar.gz'}]
pprint.pprint(client.release_data('MPTools', '0.1'))
{'author': 'Tarek Ziade',
'author_email': 'tarek@mozilla.com',
'classifiers': [],
'description': 'UNKNOWN',
'download_url': 'UNKNOWN',
'home_page': 'http://bitbucket.org/tarek/mopytools',
'keywords': None,
'license': 'UNKNOWN',
'maintainer': None,
'maintainer_email': None,
'name': 'MPTools',
'package_url': 'http://pypi.python.org/pypi/MPTools',
'platform': 'UNKNOWN',
'release_url': 'http://pypi.python.org/pypi/MPTools/0.1',
'requires_python': None,
'stable_version': None,
'summary': 'Set of tools to build Mozilla Services apps',
'version': '0.1'}
```</p></blockquote></blockquote></blockquote>

<p>这种方式的问题在于，项目元信息原本就能以静态文件的方式在简单索引协议中提供，这样可以简化安装工具的复杂性，也可以减少PyPI服务的请求数。对于诸如下载数量这样的动态数据，可以在其他接口中提供。用两种服务来获取所有的静态内容，显然不太合理。</p>

<h3>14.3.4 Python安装目录的结构</h3>

<p>在使用<code>python setup.py install</code>安装一个Python项目后，<code>Distutils</code>这一Python核心类库会负责将程序代码复制到目标系统的相应位置。</p>

<ul>
<li><em>Python包</em> 和模块会被安装到Python解释器程序所在的目录中，并随解释器启动：Ubuntu系统中会安装到<code>/usr/local/lib/python2.6/dist-packages/</code>，Fedora则是<code>/usr/local/lib/python2.6/sites-packages/</code>。</li>
<li>项目中的 <em>数据文件</em> 可以被安装到任何位置。</li>
<li><em>可执行文件</em> 会被安装到系统的<code>bin</code>目录下，依平台类型而定，可能是<code>/usr/local/bin</code>，或是其它指定的目录。</li>
</ul>


<p>从Python2.5开始，项目的元信息文件会随模块和包一起发布，名称为<code>project-version.egg-info</code>。比如，<code>virtualenv</code>项目会有一个<code>virtualenv-1.4.9.egg-info</code>文件。这些元信息文件可以被视为一个已安装项目的数据库，因为可以通过遍历其中的内容来获取已安装的项目和版本。但是，<code>Distutils</code>并没有记录项目所安装的文件列表，也就是说，我们无法彻底删除安装某个项目后产生的所有文件。可惜的是，<code>install</code>命令本身是提供了一个名为<code>--record</code>的参数的，可以将已安装的文件列表记录在文本文件中，但是这个参数并没有默认开启，而且<code>Distutils</code>的文档中几乎没有提及这个参数。</p>

<h3>14.3.5 Setuptools、Pip等工具</h3>

<p>正如介绍中所提到的，有些项目已经在尝试修复<code>Distutils</code>的问题，并取得了一些成功。</p>

<h4>依赖问题</h4>

<p>PyPI允许开发者在发布的项目中包含多个模块，还允许项目通过定义<code>Require</code>属性来声明模块级别的依赖。这两种做法都是合理的，但是同时使用就会很糟糕。</p>

<p>正确的做法应该是定义项目级别的依赖，这也是<code>Setuptools</code>在<code>Distutils</code>之上附加的一个特性。它还提供了一个名为<code>easy_install</code>的脚本来从PyPI上自动获取和安装依赖项。在实际生产中，模块级别的依赖并没有真正被使用，更多人倾向于使用<code>Setuptools</code>。然而，这些特性只是针对<code>Setuptools</code>的，并没有被<code>Distutils</code>或PyPI所接受，所以<code>Setuptools</code>实质上是一个构建在错误设计上的仿冒品。</p>

<p><code>easy_install</code>需要下载项目的压缩文档，执行<code>setup.py</code>来获取元信息，并对每个依赖项进行相同的操作。项目的依赖树会随着软件包的下载逐步勾画出来。</p>

<p>虽然PyPI上可以直接浏览项目元信息，但是<code>easy_install</code>还是需要下载所有的软件包，因为上文提到过，PyPI上的项目元信息很可能和上传时所使用的平台有关，从而和目标系统有所差异。但是这种一次性安装项目依赖的做法已经能够解决90%的问题了，的确是个很不错的特性。这也是为什么<code>Setuptools</code>被广泛采用的原因。然而，它还是有以下一些问题：</p>

<ul>
<li>如果某一个依赖项安装失败，它并没有提供回滚的选项，因此系统会处于一个不可用的状态。</li>
<li>项目依赖树是在安装一个个软件包时构建出来的，因此当其中两个依赖项产生冲突时，系统也会变的不可用。</li>
</ul>


<h4>卸载的问题</h4>

<p>虽然<code>Setuptools</code>可以在元信息中记录已安装的文件，但它并没有提供卸载功能。另一个工具<code>Pip</code>，它通过扩展<code>Setuptools</code>的元信息来记录已安装的文件，从而能够进行卸载操作。但是，这组信息又是一种自定义的内容，因此一个Python项目很可能包含四种不同的元信息：</p>

<ul>
<li><code>Distutils</code>的<code>egg-info</code>，一个单一的文件；</li>
<li><code>Setuptools</code>的<code>egg-info</code>，一个目录，记录了<code>Setuptools</code>特定的元信息；</li>
<li><code>Pip</code>的<code>egg-info</code>，是后者的扩展；</li>
<li>其它由打包系统产生的信息。</li>
</ul>


<h3>14.3.6 数据文件如何处理？</h3>

<p>在<code>Distutils</code>中，数据文件可以被安装在任意位置。你可以像这样在<code>setup.py</code>中定义一个项目的数据文件：</p>

<p><code>python
setup(…,
  packages=['mypkg'],
  package_dir={'mypkg': 'src/mypkg'},
  package_data={'mypkg': ['data/*.dat']},
  )
</code></p>

<p>那么，<code>mypkg</code>项目中所有以<code>.dat</code>为扩展名的文件都会被包含在发布包中，并随Python代码安装到目标系统。</p>

<p>对于需要安装到项目目录之外的数据文件，可以进行如下配置。他们随项目一起打包，并安装到指定的目录中：</p>

<p>```python
setup(…,</p>

<pre><code>data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),
            ('config', ['cfg/data.cfg']),
            ('/etc/init.d', ['init-script'])]
)
</code></pre>

<p>```</p>

<p>这对系统打包人员来说简直是噩梦：</p>

<ul>
<li>元信息中并不包含数据文件的信息，因此打包人员需要阅读<code>setup.py</code>文件，甚至是研究项目源码来获取这些信息。</li>
<li>不应该由开发人员来决定项目数据文件应该安装到目标系统的哪个位置。</li>
<li>数据文件没有区分类型，图片、帮助文件等都被视为同等来处理。</li>
</ul>


<p>打包人员在对项目进行打包时只能去根据目标系统的情况来修改<code>setup.py</code>文件，从而让软件包能够顺利安装。要做到这一点，他就需要阅读程序代码，修改所有用到这些文件的地方。<code>Setuptools</code>和<code>Pip</code>并没有解决这一问题。</p>

<h2>14.4 改进标准</h2>

<p>所以最后我们得到的是这样一个打包系统：所有功能都由一个模块提供，项目的元信息不完整，无法描述清楚项目中包含的所有内容。现在就让我们来做些改进。</p>

<h3>14.4.1 元信息</h3>

<p>首先，我们要修正<code>Metadata</code>标准中的内容。PEP 345定义了一个新的标准，它包含以下内容：</p>

<ul>
<li>更合理的版本定义方式</li>
<li>项目级别的依赖关系</li>
<li>使用一种静态的方式描述平台相关的属性</li>
</ul>


<h4>版本</h4>

<p>元信息标准的目标之一是能够让Python包管理工具使用相同的方式来对项目进行分类。对于版本号来说，应该让所有的工具都知道“1.1”是在“1.0”之后的。如果项目使用了自己定义的版本号命名方式，就无法做到这一点了。</p>

<p>要保证这种一致性，唯一的方法是让所有的项目都按照统一的方式来命名版本号。我们选择的方式是经典的序列版本号，在PEP 386中定义，它的格式是：</p>

<p><code>
N.N[.N]+[{a|b|c|rc}N[.N]+][.postN][.devN]
</code></p>

<p>其中：</p>

<ul>
<li><em>N</em> 是一个整数。你可以使用任意数量的N，用点号将它们分隔开来。但至少要有两个N，即“主版本.次版本”。</li>
<li><em>a, b, c</em> 分别是 <em>alpha, beta, release candidate</em> 的简写，它们后面还有一个整数。预发布版本有两种标记，c和rc，主要是为了和过去兼容，但c更简单些。</li>
<li><em>dev</em> 加一个数字表示开发版本。</li>
<li><em>post</em> 加一个数字表示已发布版本。</li>
</ul>


<p>根据项目发布周期的不同，开发版本和已发布版本可以作为两个最终版本之间的过渡版本号。大多数项目会使用开发版本。</p>

<p>按照这个形式，PEP 386定义了严格的顺序：</p>

<ul>
<li>alpha &lt; beta &lt; rc &lt; final</li>
<li>dev &lt; non-dev &lt; post, non-dev包括alpha, beta, rc或者final</li>
</ul>


<p>以下是一个完整的示例：</p>

<p>```
1.0a1 &lt; 1.0a2.dev456 &lt; 1.0a2 &lt; 1.0a2.1.dev456
  &lt; 1.0a2.1 &lt; 1.0b1.dev456 &lt; 1.0b2 &lt; 1.0b2.post345</p>

<pre><code>&lt; 1.0c1.dev456 &lt; 1.0c1 &lt; 1.0.dev456 &lt; 1.0
  &lt; 1.0.post456.dev34 &lt; 1.0.post456
</code></pre>

<p>```</p>

<p>这样定义的目标在于让其他打包系统能够将Python项目的版本号方便地转换成它们自己的版本命名规则。目前，如果上传的项目使用了PEP 345定义的元信息，PyPI会拒绝接受没有遵守PEP 386版本号命名规范的项目。</p>

<h4>依赖</h4>

<p>PEP 345定义了三个新的元信息属性，用来替换PEP 314中的<code>Requires</code>，<code>Provides</code>，和<code>Obsoletes</code>，它们是<code>Requires-Dist</code>，<code>Provides-Dist</code>，<code>Obsoletes-Dist</code>。这些属性可以在元信息中出现多次。</p>

<p><code>Requires-Dist</code>中定义了项目所依赖的软件包，使用依赖项目的<code>Name</code>元信息，并可以跟上一个版本号。这些依赖项目的名称必须能在PyPI中找到，且版本号命名规则要遵守PEP 386中的定义。以下是一些示例：</p>

<p><code>
Requires-Dist: pkginfo
Requires-Dist: PasteDeploy
Requires-Dist: zope.interface (&gt;3.5.0)
</code></p>

<p><code>Provides-Dist</code>用来定义项目中包含的其他项目，常用于合并两个项目的情形。比如，ZODB项目可以包含名为<code>transaction</code>的项目，并声明：</p>

<p><code>
Provides-Dist: transaction
</code></p>

<p><code>Obsoletes-Dist</code>主要用于将其它项目标记为本项目的过期版本。</p>

<p><code>
ObsoletesDist: OldName
</code></p>

<h4>环境标识</h4>

<p>环境标识可以添加在上述三个属性的后面，使用分号分隔，用来标识该属性在什么样的目标环境中生效。以下是一些示例：</p>

<p><code>
Requires-Dist: pywin32 (&gt;1.0); sys.platform == 'win32'
Obsoletes-Dist: pywin31; sys.platform == 'win32'
Requires-Dist: foo (1,!=1.3); platform.machine == 'i386'
Requires-Dist: bar; python_version == '2.4' or python_version == '2.5'
Requires-External: libxslt; 'linux' in sys.platform
</code></p>

<p>这种简易的语法足以让非Python程序员看懂：它使用<code>==</code>或<code>in</code>运算符（含<code>!=</code>和<code>not in</code>），且可以通过逻辑运算符连接。PEP 345中规定以下属性可以使用这种语法：</p>

<ul>
<li><code>Requires-Python</code></li>
<li><code>Requires-External</code></li>
<li><code>Requires-Dist</code></li>
<li><code>Provides-Dist</code></li>
<li><code>Obsoletes-Dist</code></li>
<li><code>Classifier</code></li>
</ul>


<h3>14.4.2 用户安装了什么？</h3>

<p>出于互通性的考虑，Python项目的安装格式必须一致。要让安装工具A能够检测到工具B安装的项目，它们就必须共享和更新相同的项目列表。</p>

<p>当然，理想中用户会在系统中只使用一种安装工具，但是他们也许会需要迁移到另一种工具以获得一些新的特性。比如，Mac OS X操作系统自带了<code>Setuptools</code>，因而装有<code>easy_install</code>工具。当他们想要切换到新的工具时，该工具就必须兼容现有的环境。</p>

<p>如果系统使用类似RPM这样的工具管理Python软件包，那么其它安装工具在安装新项目时是无法通知到系统的。更糟糕的是，即便Python安装工具能够通知到中央打包系统，我们也必须在Python元信息和系统元信息之间做一个映射。比如，项目的名称在两个系统中可能是不一致的。造成这种问题的原因也多种多样，比较常见的原因是命名冲突，即RPM源中已经有一个同名的项目了。另一个原因是项目名称中包含了<code>python</code>这个前缀，从而破坏了RPM系统的规范。比如，你的项目名称是<code>foo-python</code>，那在RPM源中很可能被表示为<code>python-foo</code>。</p>

<p>一种解决办法是不去触碰全局的Python环境，而是使用一个隔离的环境，如<code>Virtualenv</code>。</p>

<p>但不管怎样，采用统一的Python安装格式还是有必要的，因为其它一些打包系统在为自己安装Python项目时还是需要考虑互通性。当第三方打包系统新安装了一个项目，并在自身的数据库中注册后，它还需要为Python安装环境生成一个正确的元信息，从而让项目在这个环境中变得可见，或能通过该Python环境提供的API检索到。</p>

<p>元信息的映射问题可以这样描述：因为RPM系统知道自己安装了哪些Python项目，它就能生成合适的Python元信息。例如，它知道<code>python26-webob</code>项目在PyPI中的名字是<code>WebOb</code>。</p>

<p>回到我们的规范：PEP 376定义的项目安装规范和<code>Seteptools</code>以及<code>Pip</code>的格式很相似，它是一个以<code>dist-info</code>结尾的目录，包含以下内容：</p>

<ul>
<li><code>METADATA</code>：元信息，其格式在PEP 345、PEP 314和PEP 241中描述。</li>
<li><code>RECORD</code>：项目安装的文件列表，以类似csv的格式保存。</li>
<li><code>INSTALLER</code>：安装项目所使用的工具。</li>
<li><code>REQUESTED</code>：如果这个文件存在，则表明这个项目是被显式安装的，即并不是作为依赖项而安装。</li>
</ul>


<p>如果所有的安装工具都能识别这种格式，我们在管理Python项目时就不需要依赖特定的安装工具和它提供的特性了。此外，PEP 376将元信息设计为一个目录，这样就能方便地扩展。事实上，下一章要描述的<code>RESOURCES</code>文件很可能会在不久的将来添加到元信息中，而不用改变PEP 376标准。当事实证明这个文件能被所有的安装工具使用，则会将它修订到PEP中。</p>

<h3>14.4.3 数据文件的结构</h3>

<p>前面已经提到，我们需要能够让打包者来决定项目的数据文件安装在哪个位置，而不用修改代码。同样，也要能够让开发者在开发时不用去考虑数据文件的存放位置。我们的解决方案很普通：重定向。</p>

<h4>使用数据文件</h4>

<p>假设你的<code>MPTools</code>项目需要使用一个配置文件。开发者会将改文件放到Python包安装目录中，并使用<code>__file__</code>去引用：</p>

<p>```python
import os</p>

<p>here = os.path.dirname(<strong>file</strong>)
cfg = open(os.path.join(here, 'config', 'mopy.cfg'))
```</p>

<p>这样编写代码意味着该配置文件必须和代码放在相同的位置，一个名为<code>config</code>的子目录下。</p>

<p>我们设计的新的数据文件结构以项目为根节点，开发者可以定义任意的文件目录结构，而不用关心根目录是存放在软件安装目录中或是其它目录。开发者可以使用<code>pkgutil.open</code>来访问这些数据文件：</p>

<p>```python
import os
import pkgutil</p>

<h1>Open the file located in config/mopy.cfg in the MPTools project</h1>

<p>cfg = pkgutil.open('MPTools', 'config/mopy.cfg')
```</p>

<p><code>pkgutil.open</code>命令会检索项目元信息中的<code>RESOURCES</code>文件，该文件保存的是一个简单的映射信息——文件名称和它所存放的位置：</p>

<p><code>
config/mopy.cfg {confdir}/{distribution.name}
</code></p>

<p>其中，<code>{confdir}</code>变量指向系统的配置文件目录，<code>{distribution.name}</code>变量表示的是Python项目名称。</p>

<p><img src="http://www.aosabook.org/images/packaging/find-file.png" alt="图14.4：定位一个文件" /></p>

<p>图14.4：定位一个文件</p>

<p>只要安装过程中生成了<code>RESOURCES</code>文件，这个API就能帮助开发者找到<code>mopy.cfg</code>文件。又因为<code>config/mopy.cfg</code>是一个相对于项目的路径，我们就能在开发模式下提供一个本地的路径，让<code>pkgutil</code>能够找到它。</p>

<h4>声明数据文件</h4>

<p>实际使用中，我们可以在<code>setup.cfg</code>文件中用映射关系来定义数据文件的存放位置。映射关系的形式是<code>(glob-style pattern, target)</code>，每个“模式”指向项目中的一个或一组文件，“目标”则表示实际安装位置，可以包含变量名，用花括号括起。例如，<code>MPTools</code>的<code>setup.cfg</code>文件可以是以下内容：</p>

<p>```
[files]
resources =</p>

<pre><code>    config/mopy.cfg {confdir}/{application.name}/
    images/*.jpg    {datadir}/{application.name}/
</code></pre>

<p>```</p>

<p><code>sysconfig</code>模块提供了一组可用的变量，并为不同的操作系统提供了默认值。例如，<code>{confdir}</code>在Linux下是<code>/etc</code>。安装工具就能结合<code>sysconfig</code>模块来决定数据文件的存放位置。最后，它会生成一个<code>RESOURCES</code>文件，这样<code>pkgutil</code>就能找到这些文件了：</p>

<p><img src="http://www.aosabook.org/images/packaging/installer.png" alt="图14.5：安装工具" /></p>

<p>图14.5：安装工具</p>

<h3>14.4.4 改进PypI</h3>

<p>上文提到过，PyPI目前是一个单点故障源。PEP 380中正式提出了这个问题，并定义了一个镜像协议，使得用户可以在PyPI出现问题时连接到其他源。这个协议的目的是让社区成员可以在世界各地搭建起PyPI镜像。</p>

<p><img src="http://www.aosabook.org/images/packaging/mirroring.png" alt="图14.6：镜像" /></p>

<p>图14.6：镜像</p>

<p>镜像列表的格式是<code>X.pypi.python.org</code>，其中<code>X</code>是一个字母序列，如<code>a,b,c,…,aa,ab,….</code>，<code>a.pypi.python.org</code>是主服务器，b字母开始是从服务器。域名<code>last.pypi.python.org</code>的A记录指向这个列表中的最后一个服务器，这样PyPI的使用者就能够根据DNS记录来获取完整的服务器镜像列表了。</p>

<p>比如，以下代码获取到的最后一个镜像地址是<code>h.pypi.python.org</code>，表示当前PyPI有7个镜像服务器（b至h）：</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>import socket
socket.gethostbyname_ex('last.pypi.python.org')[0]
'h.pypi.python.org'
```</p></blockquote></blockquote></blockquote>

<p>这样一来，客户端还可以根据域名的IP地址来决定连接最近的镜像服务器，或者在服务器发生故障时自动重连到新的地址。镜像协议本身要比rsync更复杂一些，因为我们需要保证下载统计量的准确性，并提供最基本的安全性保障。</p>

<h4>同步</h4>

<p>镜像必须尽可能降低和主服务器之间的数据交换，要达到这个目的，就必须在PyPI的XML-RPC接口中加入<code>changelog</code>信息，以保证只获取变化的内容。对于每个软件包“P”，镜像必须复制<code>/simple/P/</code>和<code>/serversig/P</code>这两组信息。</p>

<p>如果中央服务器中删除了一个软件包，它就必须删除所有和它有关的数据。为了检测软件包文件的变动，可以缓存文件的ETag信息，并通过<code>If-None-Match</code>头来判断是否可以跳过传输过程。当同步完成后，镜像就将<code>/last-modified</code>文件设置为当前的时间。</p>

<h4>统计信息</h4>

<p>当用户在镜像中下载一个软件包时，镜像就需要将这个事件报告给中央服务器，继而广播给其他镜像服务器。这样就能保证下载工具在任意镜像都能获得正确的下载量统计信息。</p>

<p>统计信息以CSV文件的格式保存在中央服务器的<code>stats</code>目录中，按照日和周分隔。每个镜像服务器需要提供一个<code>local-stats</code>目录来存放它自己的统计信息。文件中保存了每个软件包的下载数量，以及它们的下载工具。中央服务器每天都会从镜像服务器中获取这些信息，将其合并到全局的<code>stats</code>目录，这样就能保证镜像服务器中的<code>local-stats</code>目录中的数据至少是每日更新的。</p>

<h4>镜像服务器的合法性</h4>

<p>在分布式的镜像系统中，客户端需要能够验证镜像服务器的合法性。如果不这样做，就可能产生以下威胁：</p>

<ul>
<li>中央索引发生错误</li>
<li>镜像服务被篡改</li>
<li>服务器和客户端之间遭到拦截攻击</li>
</ul>


<p>对于第一种攻击，软件包的作者就需要使用自己的PGP密钥来对软件包进行加密，这样其他用户就能判断他所下载的软件包是来自可信任的作者的。镜像服务协议中只对第二种攻击做了预防，不过有些措施也可以预防拦截攻击。</p>

<p>中央服务器会在<code>/serverkey</code>这个URL下提供一个DSA密钥，它是用<code>opensll dsa-pubout</code><sup>3</sup>生成的PEM格式的密钥。这个URL不能被镜像服务器收录，客户端必须从主服务器中获取这个serverkey密钥，或者使用PyPI客户端本身自带的密钥。镜像服务器也是需要下载这个密钥的，用来检测密钥是否有更新。</p>

<p>对于每个软件包，<code>/serversig/package</code>中存放了它们的镜像签名。这是一个DSA签名，和URL<code>/simple/package</code>包含的内容对等，采用DER格式，是SHA-1和DSA的结合<sup>4</sup>。</p>

<p>客户端从镜像服务器下载软件包时必须经过以下验证：</p>

<ol>
<li>下载<code>/simple</code>页面，计算它的<code>SHA-1</code>哈希值。</li>
<li>计算这个哈希值的DSA签名。</li>
<li>下载对应的<code>/serversig</code>，将它和第二步中生成的签名进行比对。</li>
<li>计算并验证所有下载文件的MD5值（和<code>/simple</code>页面中的内容对比）。</li>
</ol>


<p>在从中央服务器下载软件包时不需要进行上述验证，客户端也不应该进行验证，以减少计算量。</p>

<p>这些密钥大约每隔一年会被更新一次。镜像服务器需要重新获取所有的<code>/serversig</code>页面内容，使用镜像服务的客户端也需要通过可靠的方式获取新密钥。一种做法是从<code>https://pypi.python.org/serverkey</code>下载。为了检测拦截攻击，客户端需要通过CAC认证中心验证服务端的SSL证书。</p>

<h2>14.5 实施细节</h2>

<p>上文提到的大多数改进方案都在<code>Distutils2</code>中实现了。<code>setup.py</code>文件已经退出历史舞台，取而代之的是<code>setup.cfg</code>，一个类似<code>.ini</code>类型的文件，它描述了项目的所有信息。这样做可以让打包人员方便地改变软件包的安装方式，而不需要接触Python语言。以下是一个配置文件的示例：</p>

<p>```
[metadata]
name = MPTools
version = 0.1
author = Tarek Ziade
author-email = tarek@mozilla.com
summary = Set of tools to build Mozilla Services apps
description-file = README
home-page = http://bitbucket.org/tarek/pypi2rpm
project-url: Repository, http://hg.mozilla.org/services/server-devtools
classifier = Development Status :: 3 - Alpha</p>

<pre><code>License :: OSI Approved :: Mozilla Public License 1.1 (MPL 1.1)
</code></pre>

<p>[files]
packages =</p>

<pre><code>    mopytools
    mopytools.tests
</code></pre>

<p>extra_files =</p>

<pre><code>    setup.py
    README
    build.py
    _build.py
</code></pre>

<p>resources =</p>

<pre><code>etc/mopytools.cfg {confdir}/mopytools
</code></pre>

<p>```</p>

<p><code>Distutils2</code>会将这个文件用作于：</p>

<ul>
<li>生成<code>META-1.2</code>格式的元信息，可以用作多种用途，如在PyPI上注册项目。</li>
<li>执行任何打包管理命令，如<code>sdist</code>。</li>
<li>安装一个以<code>Distutils2</code>为基础的项目。</li>
</ul>


<p><code>Distutils2</code>还通过<code>version</code>模块实现了<code>VERSION</code>元信息。</p>

<p>对<code>INSTALL-DB</code>元信息的实现会被包含在Python3.3的<code>pkgutil</code>模块中。在过度版本中，它的功能会由<code>Distutils2</code>完成。它所提供的API可以让我们浏览系统中已安装的项目。</p>

<p>以下是<code>Distutils2</code>提供的核心功能：</p>

<ul>
<li>安装、卸载</li>
<li>依赖树</li>
</ul>


<h2>14.6 经验教训</h2>

<h3>14.6.1 PEP的重要性</h3>

<p>要改变像Python打包系统这样庞大和复杂的架构必须通过谨慎地修改PEP标准来进行。据我所知，任何对PEP的修改和添加都要历经一年左右的时间。</p>

<p>社区中一直以来有个错误的做法：为了改善某个问题，就肆意扩展项目元信息，或是修改Python程序的安装方式，而不去尝试修订它所违背的PEP标准。</p>

<p>换句话说，根据你所使用的安装工具的不同，如<code>Distutils</code>和<code>Setuptools</code>，它们安装应用程序的方式就是不同的。这些工具的确解决了一些问题，但却会引发一连串的新问题。以操作系统的打包工具为例，管理员必须面对多个Python标准：官方文档所描述的标准，<code>Setuptools</code>强加给大家的标准。</p>

<p>但是，<code>Setuptools</code>能够有机会在实际环境中大范围地（在整个社区中）进行实验，创新的进度很快，得到的反馈信息也是无价的。我们可以据此撰写出更切合实际的PEP新标准。所以，很多时候我们需要能够察觉到某个第三方工具在为Python社区做出贡献，并应该起草一个新的PEP标准来解决它所提出的问题。</p>

<h3>14.6.2 一个被纳入标准库的项目就已经死亡了一半</h3>

<p>这个标题是援引Guido van Rossum的话，而事实上，Python的这种战争式的哲学也的确冲击了我们的努力成果。</p>

<p><code>Distutils</code>是Python标准库之一，将来<code>Distutils2</code>也会成为标准库。一个被纳入标准库的项目很难再对其进行改造。虽然我们有正常的项目更新流程，即经过两个Python次版本就可以对某个API进行删改，但一旦某个API被发布，它必定会持续存在多年。</p>

<p>因此，对标准库中某个项目的一次修改并不是简单的bug修复，而很有可能影响整个生态系统。所以，当你需要进行重大更新时，就必须创建一个新的项目。</p>

<p>我之所以深有体会，就是因为在我对<code>Distutils</code>进行了超过一年的修改后，还是不得不回滚所有的代码，开启一个新的<code>Distutils2</code>项目。将来，如果我们的标准又一次发生了重大改变，很有可能会产生<code>Distutils3</code>项目，除非未来某一天标准库会作为独立的项目发行。</p>

<h3>14.6.3 向前兼容</h3>

<p>要改变Python项目的打包方式，其过程是非常漫长的：Python的生态系统中包含了那么多的项目，它们都采用旧的打包工具管理，一定会遇到诸多阻力。（文中一些章节描述的问题，我们花费了好几年才达成共识，而不是我之前预想的几个月。）对于Python3，可能会花费数年的时间才能将所有的项目都迁移到新的标准中去。</p>

<p>这也是为什么我们做的任何修改都必须兼容旧的打包工具，这是<code>Distutils2</code>编写过程中非常棘手的问题。</p>

<p>例如，一个以新标准进行打包的项目可能会依赖一个尚未采用新标准的其它项目，我们不能因此中断安装过程，并告知用户这是一个无法识别的依赖项。</p>

<p>举例来说，<code>INSTALL-DB</code>元信息的实现中会包含那些用<code>Distutils</code>、<code>Pip</code>、<code>Distribution</code>、或<code>Setuptools</code>安装的项目。<code>Distutils2</code>也会为那些使用<code>Distutils</code>安装的项目生成新的元信息。</p>

<h2>14.7 参考和贡献者</h2>

<p>本文的部分章节直接摘自PEP文档，你可以在<code>http://python.org</code>中找到原文：</p>

<ul>
<li>PEP 241: Metadata for Python Software Packages 1.0: http://python.org/peps/pep-0214.html</li>
<li>PEP 314: Metadata for Python Software Packages 1.1: http://python.org/peps/pep-0314.html</li>
<li>PEP 345: Metadata for Python Software Packages 1.2: http://python.org/peps/pep-0345.html</li>
<li>PEP 376: Database of Installed Python Distributions: http://python.org/peps/pep-0376.html</li>
<li>PEP 381: Mirroring infrastructure for PyPI: http://python.org/peps/pep-0381.html</li>
<li>PEP 386: Changing the version comparison module in Distutils: http://python.org/peps/pep-0386.html</li>
</ul>


<p>在这里我想感谢所有为打包标准的制定做出贡献的人们，你可以在PEP中找到他们的名字。我还要特别感谢“打包别动队”的成员们。还要谢谢Alexis Metaireau、Toshio Kuratomi、Holger Krekel、以及Stefane Fermigier，感谢他们对本文提供的反馈。</p>

<p>本章中讨论的项目有：</p>

<ul>
<li>Distutils: http://docs.python.org/distutils</li>
<li>Distutils2: http://packages.python.org/Distutils2</li>
<li>Distribute: http://packages.python.org/distribute</li>
<li>Setuptools: http://pypi.python.org/pypi/setuptools</li>
<li>Pip: http://pypi.python.org/pypi/pip</li>
<li>Virtualenv: http://pypi.python.org/pypi/virtualenv</li>
</ul>


<h2>脚注</h2>

<ol>
<li>文中引用的Python改进提案（Python Enhancement Proposals，简称PEP）会在本文最后一节整理。</li>
<li>过去被命名为CheeseShop</li>
<li>即RFC 3280 SubjectPublishKeyInfo中定义的1.3.14.3.2.12算法。</li>
<li>即RFC 3279 Dsa-Sig-Value中定义的1.2.840.10040.4.3算法。</li>
</ol>

]]></content>
  </entry>
  
</feed>
