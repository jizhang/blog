
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Clojure实战(5)：Storm实时计算框架 - Ji ZHANG's Blog</title>
  <meta name="author" content="Ji ZHANG">

  
  <meta name="description" content="Storm简介 上一章介绍的Hadoop工具能够对海量数据进行批量处理，采用分布式的并行计算架构，只需使用其提供的MapReduce API编写脚本即可。但随着人们对数据实时性的要求越来越高，如实时日志分析、实时推荐系统等，Hadoop就无能为力了。 这时，Storm诞生了。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://shzhangji.com/blog/2013/04/22/cia-storm">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Ji ZHANG's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37223379-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Ji ZHANG's Blog</a></h1>
  
    <h2>If I rest, I rust.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:shzhangji.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Clojure实战(5)：Storm实时计算框架</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-22T12:11:00+08:00" pubdate data-updated="true">Apr 22<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Storm简介</h2>

<p>上一章介绍的Hadoop工具能够对海量数据进行批量处理，采用分布式的并行计算架构，只需使用其提供的MapReduce API编写脚本即可。但随着人们对数据实时性的要求越来越高，如实时日志分析、实时推荐系统等，Hadoop就无能为力了。</p>

<p>这时，Storm诞生了。它的设计初衷就是提供一套分布式的实时计算框架，实现低延迟、高并发的海量数据处理，被誉为“Realtime Hadoop”。它提供了简单易用的API接口用于编写实时处理脚本；能够和现有各类消息系统整合；提供了HA、容错、事务、RPC等高级特性。</p>

<p>Storm的官网是：<a href="http://storm-project.net/">storm-project.net</a>，它的<a href="https://github.com/nathanmarz/storm/wiki">Wiki</a>上有非常详尽的说明文档。</p>

<h3>Storm与Clojure</h3>

<p>Storm的主要贡献者<a href="https://github.com/nathanmarz">Nathan Marz</a>和<a href="https://github.com/xumingming">徐明明</a>都是活跃的Clojure开发者，因此在Storm框架中也提供了原生的<a href="https://github.com/nathanmarz/storm/wiki/Clojure-DSL">Clojure DSL</a>。本文就将介绍如何使用这套DSL来编写Storm处理脚本。</p>

<p>Storm集群的安装配置这里不会讲述，具体请参考<a href="https://github.com/nathanmarz/storm/wiki/Setting-up-a-Storm-cluster">这篇文档</a>。下文的脚本都运行在“本地模式”之下，因此即使不搭建集群也可以运行和调试。</p>

<!-- more -->


<h2>Storm脚本的组件</h2>

<p><img src="http://storm-project.net/images/topology.png" height="200"></p>

<p>Storm脚本的英文名称叫做“Storm Topology”，直译过来是“拓扑结构”。这个脚本由两大类组建构成，<code>Spout</code>和<code>Bolt</code>，分别可以有任意多个。他们之间以“数据流”的方式连接起来，因此整体看来就像一张拓扑网络，因此得名<code>Topology</code>。</p>

<h3>Spout</h3>

<p>数据源节点，是整个脚本的入口。Storm会不断调用该节点的<code>nextTuple()</code>方法来获取数据，分发给下游<code>Bolt</code>节点。<code>nextTuple()</code>方法中可以用各种方式从外部获取数据，如逐行读取一个文件、从消息队列（ZeroMQ、Kafka）中获取消息等。一个Storm脚本可以包含多个<code>Spout</code>节点，从而将多个数据流汇聚到一起进行处理。</p>

<h3>Bolt</h3>

<p>数据处理节点，它是脚本的核心逻辑。它含有一个<code>execute()</code>方法，当接收到消息时，Storm会调用这个函数，并将消息传递给它。我们可以在<code>execute()</code>中对消息进行过滤（只接收符合条件的数据），或者进行聚合（统计某个条件的数据出现的次数）等。处理完毕后，这个节点可以选择将处理后的消息继续传递下去，或是持久化到数据库中。</p>

<p><code>Bolt</code>同样是可以有多个的，且能够前后组合。<code>Bolt C</code>可以同时收取<code>Bolt A</code>和<code>Bolt B</code>的数据，并将处理结果继续传递给<code>Bolt D</code>。</p>

<p>此外， <em>一个Bolt可以产生多个实例</em> ，如某个<code>Bolt</code>包含复杂耗时的计算，那在运行时可以调高其并发数量（实例的个数），从而达到并行处理的目的。</p>

<h3>Tuple</h3>

<p><code>Tuple</code>是消息传输的基本单元，一条消息即一个<code>Tuple</code>。可以将其看做是一个<code>HashMap</code>对象，它能够包含任何可序列化的数据内容。对于简单的数据类型，如整型、字符串、Map等，Storm提供了内置的序列化支持。而用户自定义的数据类型，可以通过指定序列化/反序列化函数来处理。</p>

<h3>Stream Grouping</h3>

<p>想象一个<code>Spout</code>连接了两个<code>Bolt</code>（或一个<code>Bolt</code>的两个实例），那数据应该如何分发呢？你可以选择轮询（<code>ShuffleGrouping</code>），或是广播（<code>GlobalGrouping</code>）、亦或是按照某一个字段进行哈希分组（<code>FieldGrouping</code>），这些都称作为<a href="https://github.com/nathanmarz/storm/wiki/Concepts#stream-groupings"><code>Stream Grouping</code></a>。</p>

<h2>示例：WordCount</h2>

<p>下面我们就来实现一个实时版的WordCount脚本，它由以下几个组件构成：</p>

<ul>
<li>sentence-spout：从已知的一段文字中随机选取一句话发送出来；</li>
<li>split-bolt：将这句话按空格分割成单词；</li>
<li>count-bolt：统计每个单词出现的次数，每五秒钟打印一次，并清零。</li>
</ul>


<h3>依赖项和配置文件</h3>

<p>首先使用<code>lein new</code>新建一个项目，并修改<code>project.clj</code>文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defproject </span><span class="nv">cia-storm</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
</span><span class='line'>  <span class="nv">...</span>
</span><span class='line'>  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.4.0&quot;</span><span class="p">]</span>
</span><span class='line'>                 <span class="p">[</span><span class="nv">org.clojure/tools.logging</span> <span class="s">&quot;0.2.6&quot;</span><span class="p">]]</span>
</span><span class='line'>  <span class="ss">:profiles</span> <span class="p">{</span><span class="ss">:dev</span> <span class="p">{</span><span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">storm</span> <span class="s">&quot;0.8.2&quot;</span><span class="p">]]}}</span>
</span><span class='line'>  <span class="ss">:plugins</span> <span class="p">[[</span><span class="nv">lein2-eclipse</span> <span class="s">&quot;2.0.0&quot;</span><span class="p">]]</span>
</span><span class='line'>  <span class="ss">:aot</span> <span class="p">[</span><span class="nv">cia-storm.wordcount</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>:profiles</code>表示定义不同的用户配置文件。Leiningen有类似于Maven的配置文件体系（profile），每个配置文件中可以定义<code>project.clj</code>所支持的各种属性，执行时会进行合并。<code>lein</code>命令默认调用<code>:dev</code>、<code>:user</code>等配置文件，可以使用<code>lein with-profiles prod run</code>来指定配置文件。具体可以参考<a href="https://github.com/technomancy/leiningen/blob/master/doc/PROFILES.md">这份文档</a>。</p>

<p>这里将<code>[storm "0.8.2"]</code>依赖项定义在了<code>:dev</code>配置下，如果直接定义在外层的<code>:dependencies</code>下，那在使用<code>lein uberjar</code>进行打包时，会将<code>storm.jar</code>包含在最终的Jar包中，提交到Storm集群运行时就会报冲突。而<code>lein uberjar</code>默认会跳过<code>:dev</code>配置，所以才这样定义。</p>

<p><code>:aot</code>表示<code>Ahead Of Time</code>，即预编译。我们在<a href="http://shzhangji.com/blog/2012/12/16/cia-noir-3/">Clojure实战（3）</a>中提过<code>:gen-class</code>这个标识表示为当前<code>.clj</code>文件生成一个<code>.class</code>文件，从而能够作为<code>main</code>函数使用，因此也需要在<code>project.clj</code>中添加<code>:main</code>标识，指向这个<code>.clj</code>文件的命名空间。如果想为其它的命名空间也生成对应的<code>.class</code>文件，就需要用到<code>:aot</code>了。它的另一个用处是加速Clojure程序的启动速度。</p>

<h3>sentence-spout</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">cia-storm.wordcount</span>
</span><span class='line'>  <span class="nv">...</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:use</span> <span class="p">[</span><span class="nv">backtype.storm</span> <span class="nv">clojure</span> <span class="nv">config</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">defspout</span> <span class="nv">sentence-spout</span> <span class="p">[</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">conf</span> <span class="nv">context</span> <span class="nv">collector</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sentences</span> <span class="p">[</span><span class="s">&quot;a little brown dog&quot;</span>
</span><span class='line'>                   <span class="s">&quot;the man petted the dog&quot;</span>
</span><span class='line'>                   <span class="s">&quot;four score and seven years ago&quot;</span>
</span><span class='line'>                   <span class="s">&quot;an apple a day keeps the doctor away&quot;</span><span class="p">]]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">spout</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">nextTuple</span> <span class="p">[]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">1000</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">emit-spout!</span> <span class="nv">collector</span> <span class="p">[(</span><span class="nf">rand-nth</span> <span class="nv">sentences</span><span class="p">)])))))</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>defspout</code>是定义在<code>backtype.storm.clojure</code>命名空间下的宏，可以<a href="https://github.com/nathanmarz/storm/blob/master/storm-core/src/clj/backtype/storm/clojure.clj#L93">点此</a>查看源码。以下是各个部分的说明：</p>

<ul>
<li><code>sentence-spout</code>是该组件的名称。</li>
<li><code>["sentence"]</code>表示该组件输出一个字段，名称为“sentence”。</li>
<li><code>[conf context collector]</code>用于接收Storm框架传入的参数，如配置对象、上下文对象、下游消息收集器等。</li>
<li><code>spout</code>表示开始定义数据源组件需要用到的各类方法。它实质上是生成一个实现了ISpout接口的对象，从而能够被Storm框架调用。</li>
<li><code>nextTuple</code>是ISpout接口必须实现的方法之一，Storm会不断调用这个方法，获取数据。这里使用<code>Thread#sleep</code>函数来控制调用的频率。</li>
<li><code>emit-spout!</code>是一个函数，用于向下游发送消息。</li>
</ul>


<p>ISpout还有open、ack、fail等函数，分别表示初始化、消息处理成功的回调、消息处理失败的回调。这里我们暂不深入讨论。</p>

<h3>split-bolt</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defbolt</span> <span class="nv">split-bolt</span> <span class="p">[</span><span class="s">&quot;word&quot;</span><span class="p">]</span> <span class="p">{</span><span class="ss">:prepare</span> <span class="nv">true</span><span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">conf</span> <span class="nv">context</span> <span class="nv">collector</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">bolt</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">execute</span> <span class="p">[</span><span class="nv">tuple</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">words</span> <span class="p">(</span><span class="nf">.split</span> <span class="p">(</span><span class="nf">.getString</span> <span class="nv">tuple</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot; &quot;</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">w</span> <span class="nv">words</span><span class="p">]</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">emit-bolt!</span> <span class="nv">collector</span> <span class="p">[</span><span class="nv">w</span><span class="p">])))</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">ack!</span> <span class="nv">collector</span> <span class="nv">tuple</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>defbolt</code>用于定义一个Bolt组件。整段代码的结构和<code>defspout</code>是比较相似的。<code>bolt</code>宏会实现为一个IBolt对象，<code>execute</code>是该接口的方法之一，其它还有<code>prepare</code>和<code>cleanup</code>。<code>execute</code>方法接收一个参数<code>tuple</code>，用于接收上游消息。</p>

<p><code>ack!</code>是<code>execute</code>中必须调用的一个方法。Storm会对每一个组件发送出来的消息进行追踪，上游组件发出的消息需要得到下游组件的“确认”（ACKnowlege），否则会一直堆积在内存中。对于Spout而言，如果消息得到确认，会触发<code>ISpout#ack</code>函数，否则会触发<code>ISpout#fail</code>函数，这时Spout可以选择重发或报错。</p>

<p>代码中比较怪异的是<code>{:prepare true}</code>。<code>defspout</code>和<code>defbolt</code>有两种定义方式，即prepare和非prepare。两者的区别在于：</p>

<ul>
<li>参数不同，prepare方式下接收的参数是<code>[conf context collector]</code>，非prepare方式下，<code>defspout</code>接收的是<code>[collector]</code>，<code>defbolt</code>是[tuple collector]`。</li>
<li>prepare方式下需要调用<code>spout</code>和<code>bolt</code>宏来编写组件代码，而非prepare方式则不需要——<code>defspout</code>会默认生成<code>nextTuple()</code>函数，<code>defbolt</code>默认生成<code>execute(tuple)</code>。</li>
<li>只有prepare方式下才能指定<code>ISpout#open</code>、<code>IBolt#prepare</code>等函数，非prepare不能。</li>
<li><code>defspout</code>默认使用prepare方式，<code>defbolt</code>默认使用非prepare方式。</li>
</ul>


<p>因此，<code>split-bolt</code>可以按如下方式重写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defbolt</span> <span class="nv">split-bolt</span> <span class="p">[</span><span class="s">&quot;word&quot;</span><span class="p">]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">tuple</span> <span class="nv">collector</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">words</span> <span class="p">(</span><span class="nf">.split</span> <span class="p">(</span><span class="nf">.getString</span> <span class="nv">tuple</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot; &quot;</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">w</span> <span class="nv">words</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">emit-bolt!</span> <span class="nv">collector</span> <span class="p">[</span><span class="nv">w</span><span class="p">]))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">ack!</span> <span class="nv">collector</span> <span class="nv">tuple</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>prepare方式可以用于在组件中保存状态，具体请看下面的计数Bolt。</p>

<h3>count-bolt</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defbolt</span> <span class="nv">count-bolt</span> <span class="p">[]</span> <span class="p">{</span><span class="ss">:prepare</span> <span class="nv">true</span><span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">conf</span> <span class="nv">context</span> <span class="nv">collector</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">counts</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{})]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">bolt</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">execute</span> <span class="p">[</span><span class="nv">tuple</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">word</span> <span class="p">(</span><span class="nf">.getString</span> <span class="nv">tuple</span> <span class="mi">0</span><span class="p">)]</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">swap!</span> <span class="nv">counts</span> <span class="p">(</span><span class="nb">partial merge-with </span><span class="nv">+</span><span class="p">)</span> <span class="p">{</span><span class="nv">word</span> <span class="mi">1</span><span class="p">}))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">ack!</span> <span class="nv">collector</span> <span class="nv">tuple</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>原子（Atom）</h4>

<p><code>atom</code>是我们遇到的第一个可变量（Mutable Variable），其它的有Ref、Agent等。Atom是“原子”的意思，我们很容易想到原子性操作，即同一时刻只有一个线程能够修改Atom的值，因此它是处理并发的一种方式。这里我们使用Atom来保存每个单词出现的数量。以下是Atom的常用操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">cnt</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">println </span><span class="err">@</span><span class="nv">cnt</span><span class="p">)</span> <span class="c1">; 使用@符号获取Atom中的值。</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">cnt</span> <span class="nv">inc</span><span class="p">)</span> <span class="c1">; 将cnt中的值置换为(inc @cnt)，并返回该新的值</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">println </span><span class="err">@</span><span class="nv">cnt</span><span class="p">)</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">cnt</span> <span class="nb">+ </span><span class="mi">10</span><span class="p">)</span> <span class="c1">; 新值为(+ @cnt 10)</span>
</span><span class='line'><span class="mi">11</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reset!</span> <span class="nv">cnt</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; 归零</span>
</span><span class='line'><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，<code>(swap! atom f arg ...)</code>中的<code>f</code>函数可能会被执行多次，因此要确保它没有副作用（side-effect，即不会产生其它状态的变化）。</p>

<p>再来解释一下<code>(partial merge-with +)</code>。<code>merge-with</code>函数是对map类型的一种操作，表示将一个或多个map合并起来。和<code>merge</code>不同的是，<code>merge-with</code>多接收一个<code>f</code>函数（<code>merge-with [f &amp; maps]</code>），当键名重复时，会用<code>f</code>函数去合并它们的值，而不是直接替代。</p>

<p><code>partial</code>可以简单理解为给函数设定默认值，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">add</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">5</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="mi">15</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">add-5</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">add</span> <span class="mi">5</span><span class="p">))</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">add-5</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="mi">15</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样一来，<code>(swap! counts (partial merge-with +) {word 1})</code>就可理解为：将<code>counts</code>这个Atom中的值（一个map类型）和<code>{word 1}</code>这个map进行合并，如果单词已存在，则递增1。</p>

<h4>线程（Thread）</h4>

<p>为了输出统计值，我们为count-bolt增加prepare方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">...</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">bolt</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">prepare</span> <span class="p">[</span><span class="nv">conf</span> <span class="nv">context</span> <span class="nv">collector</span><span class="p">]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">.start</span> <span class="p">(</span><span class="nf">Thread.</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span class='line'>                           <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">Thread/interrupted</span><span class="p">))</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">logging/info</span>
</span><span class='line'>                               <span class="p">(</span><span class="nf">clojure.string/join</span> <span class="s">&quot;, &quot;</span>
</span><span class='line'>                                 <span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">word</span> <span class="nv">count</span><span class="p">]</span> <span class="err">@</span><span class="nv">counts</span><span class="p">]</span>
</span><span class='line'>                                   <span class="p">(</span><span class="nb">str </span><span class="nv">word</span> <span class="s">&quot;: &quot;</span> <span class="nv">count</span><span class="p">))))</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">reset!</span> <span class="nv">counts</span> <span class="p">{})</span>
</span><span class='line'>                             <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">5000</span><span class="p">)))))))</span>
</span><span class='line'><span class="nv">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码的功能是：在Bolt开始处理消息之前启动一个线程，每隔5秒钟将<code>(atom counts)</code>中的单词出现次数打印出来，并对其进行清零操作。</p>

<p>这里我们直接使用了Java的Thread类型。读者可能会觉得好奇，Thread类型的构造函数只接收实现Runnable接口的对象，Clojure的匿名函数直接支持吗？我们做一个简单测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">greet</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Hi&quot;</span> <span class="nv">name</span><span class="p">))</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">instance? </span><span class="nv">Runnable</span> <span class="nv">greet</span><span class="p">)</span>
</span><span class='line'><span class="nv">true</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">instance? </span><span class="nv">Runnable</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">%</span><span class="p">))</span>
</span><span class='line'><span class="nv">true</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>logging</code>命名空间对应的依赖是<code>[org.clojure/tools.logging "0.2.6"]</code>，需要将其添加到<code>project.clj</code>中，它是对log4j组件的包装。这里之所以没有使用<code>println</code>输出到标准输出，是为了将该脚本上传到Storm集群中运行时也能查看到日志输出。</p>

<h3>定义和执行Topology</h3>

<p>各个组件已经定义完毕，下面让我们用它们组成一个Topology：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">mk-topology</span> <span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">topology</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;sentence&quot;</span> <span class="p">(</span><span class="nf">spout-spec</span> <span class="nv">sentence-spout</span><span class="p">)}</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;split&quot;</span> <span class="p">(</span><span class="nf">bolt-spec</span> <span class="p">{</span><span class="s">&quot;sentence&quot;</span> <span class="ss">:shuffle</span><span class="p">}</span>
</span><span class='line'>                        <span class="nv">split-bolt</span>
</span><span class='line'>                        <span class="ss">:p</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>     <span class="s">&quot;count&quot;</span> <span class="p">(</span><span class="nf">bolt-spec</span> <span class="p">{</span><span class="s">&quot;split&quot;</span> <span class="p">[</span><span class="s">&quot;word&quot;</span><span class="p">]}</span>
</span><span class='line'>                         <span class="nv">count-bolt</span>
</span><span class='line'>                         <span class="ss">:p</span> <span class="mi">2</span><span class="p">)}))</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>topology</code>同样是Clojure DSL定义的宏，它接收两个map作为参数，一个用于定义使用到的Spout，一个则是Bolt。该map的键是组件的名称，该名称用于确定各组件之间的关系。</p>

<p><code>spout-spec</code>和<code>bolt-spec</code>则定义了组件在Topology中更具体的参数。如&#8221;split&#8221;使用的是<code>split-bolt</code>这个组件，它的上游是&#8221;sentence&#8221;，使用shuffleGrouping来对消息进行分配，<code>:p 3</code>表示会启动3个<code>split-bolt</code>实例。</p>

<p>&ldquo;count&#8221;使用<code>count-bolt</code>组件，上游是&#8221;split&#8221;，但聚合方式采用了fieldGrouping，因此列出了执行哈希运算时使用的消息字段（word）。为何要使用fieldGrouping？因为我们会开启两个<code>count-bolt</code>，如果采用shuffleGrouping，那单词“a”第一次出现的消息会发送给一个<code>count-bolt</code>，第二次出现会发送给另一个<code>count-bolt</code>，这样统计结果就会错乱。如果指定了<code>:p 1</code>，即只开启一个<code>count-bolt</code>实例，就不会有这样的问题。</p>

<h4>本地模式和Cluster模式</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">cia-storm.wordcount</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">backtype.storm</span> <span class="nv">StormSubmitter</span> <span class="nv">LocalCluster</span><span class="p">])</span>
</span><span class='line'>  <span class="nv">...</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:gen-class</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">run-local!</span> <span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cluster</span> <span class="p">(</span><span class="nf">LocalCluster.</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.submitTopology</span> <span class="nv">cluster</span>
</span><span class='line'>      <span class="s">&quot;wordcount&quot;</span> <span class="p">{}</span> <span class="p">(</span><span class="nf">mk-topology</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">30000</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.shutdown</span> <span class="nv">cluster</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">submit-topology!</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">StormSubmitter/submitTopology</span>
</span><span class='line'>    <span class="nb">name </span><span class="p">{</span><span class="nv">TOPOLOGY-WORKERS</span> <span class="mi">3</span><span class="p">}</span> <span class="p">(</span><span class="nf">mk-topology</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">-main</span>
</span><span class='line'>  <span class="p">([]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">run-local!</span><span class="p">))</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">name</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">submit-topology!</span> <span class="nv">name</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们为WordCount生成一个类，它的<code>main</code>函数在没有命令行参数时会以本地模式执行Topology，若传递了参数（即指定了脚本在Cluster运行时的名称），则提交至Cluster。</p>

<p>这里直接使用了Storm的Java类，对参数有疑惑的可以参考<a href="http://nathanmarz.github.io/storm/doc-0.8.1/">Javadoc</a>。<code>TOPOLOGY-WORKERS</code>是在<code>backtype.storm.config</code>命名空间中定义的，我们在前面的代码中<code>:use</code>过了。Storm这个项目是用Java和Clojure混写的，所以查阅代码时还需仔细一些。</p>

<h4>运行结果</h4>

<p>首先我们直接用<code>lein</code>以本地模式运行该Topology：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>lein run -m cia-storm.wordcount
</span><span class='line'>6996 <span class="o">[</span>Thread-18<span class="o">]</span> INFO  cia-storm.wordcount  - doctor: 17, the: 31, a: 29, an: 17, ago: 13, seven: 13, and: 13
</span><span class='line'>6998 <span class="o">[</span>Thread-21<span class="o">]</span> INFO  cia-storm.wordcount  - four: 13, keeps: 17, away: 17, score: 13, petted: 7, brown: 12, little: 12, years: 13, man: 7, apple: 17, dog: 19, day: 17
</span><span class='line'>11997 <span class="o">[</span>Thread-18<span class="o">]</span> INFO  cia-storm.wordcount  - ago: 6, seven: 6, and: 6, doctor: 7, an: 7, the: 39, a: 28
</span><span class='line'>11998 <span class="o">[</span>Thread-21<span class="o">]</span> INFO  cia-storm.wordcount  - four: 6, keeps: 7, away: 7, score: 6, petted: 16, brown: 21, little: 21, years: 6, man: 16, apple: 7, dog: 37, day: 7
</span></code></pre></td></tr></table></div></figure>


<p>Cluster模式需要搭建本地集群，可以参考<a href="https://github.com/nathanmarz/storm/wiki/Setting-up-a-Storm-cluster">这篇文档</a>。下文使用的<code>storm</code>命令则需要配置<code>~/.storm/storm.yaml</code>文件，具体请参考<a href="https://github.com/nathanmarz/storm/wiki/Setting-up-development-environment#starting-and-stopping-topologies-on-a-remote-cluster">这篇文章</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>lein <span class="k">do </span>clean, compile, uberjar
</span><span class='line'><span class="nv">$ </span>storm jar target/cia-storm-0.1.0-SNAPSHOT-standalone.jar cia_storm.wordcount wordcount
</span><span class='line'><span class="nv">$ </span><span class="nb">cd</span> /path/to/storm/logs
</span><span class='line'><span class="nv">$ </span>tail worker-6700.log
</span><span class='line'>2013-05-11 21:26:15 wordcount <span class="o">[</span>INFO<span class="o">]</span> four: 9, keeps: 15, away: 15, score: 9, petted: 16, brown: 9, little: 9, years: 9, man: 16, apple: 15, dog: 25, day: 15
</span><span class='line'>2013-05-11 21:26:20 wordcount <span class="o">[</span>INFO<span class="o">]</span> four: 10, keeps: 9, away: 9, score: 10, petted: 18, brown: 13, little: 13, years: 10, man: 18, apple: 9, dog: 31, day: 9
</span><span class='line'><span class="nv">$ </span>tail worker-6701.log
</span><span class='line'>2013-05-11 21:27:10 wordcount <span class="o">[</span>INFO<span class="o">]</span> ago: 12, seven: 12, and: 12, doctor: 11, a: 31, an: 11, the: 25
</span><span class='line'>2013-05-11 21:27:15 wordcount <span class="o">[</span>INFO<span class="o">]</span> ago: 14, seven: 14, and: 14, doctor: 11, the: 43, a: 19, an: 11
</span></code></pre></td></tr></table></div></figure>


<h2>小结</h2>

<p>这一章我们简单介绍了Storm的设计初衷，它是如何通过分布式并行运算解决实时数据分析问题的。Storm目前已经十分稳定，且仍处于活跃的开发状态。它的一些高级特性如DRPC、Trident等，还请感兴趣的读者自行研究。</p>

<p>本文使用的WordCount示例代码：<a href="https://github.com/jizhang/cia-storm">https://github.com/jizhang/cia-storm</a>。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Ji ZHANG</span></span>

      








  


<time datetime="2013-04-22T12:11:00+08:00" pubdate data-updated="true">Apr 22<span>nd</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/tutorial/'>Tutorial</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://shzhangji.com/blog/2013/04/22/cia-storm/" data-via="zjerryj" data-counturl="http://shzhangji.com/blog/2013/04/22/cia-storm/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/03/28/perl-prime-in-action-jvm-monitoring-2/" title="Previous Post: Perl入门实战：JVM监控脚本（下）">&laquo; Perl入门实战：JVM监控脚本（下）</a>
      
      
        <a class="basic-alignment right" href="/blog/2013/04/30/manage-leiningen-project-configuration/" title="Next Post: Manage Leiningen Project Configuration">Manage Leiningen Project Configuration &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/31/generate-auto-increment-id-in-map-reduce-job/">Generate Auto-increment Id in Map-reduce Job</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/06/hive-deleteme-error/">Hive并发情况下报DELETEME表不存在的异常</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/11/ansible-faq/">Ansible FAQ</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/25/apache-hadoop-yarn-background-and-an-overview/">Apache Hadoop YARN - 项目背景与简介</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/01/introducing-cascalog-a-clojure-based-query-language-for-hado/">Cascalog：基于Clojure的Hadoop查询语言</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jizhang">@jizhang</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jizhang',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
<a href="http://stackoverflow.com/users/1030720/jerry">
<img src="http://stackoverflow.com/users/flair/1030720.png?theme=clean" width="208" height="58" alt="profile for Jerry at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for Jerry at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
</a>
</section>

<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/zjerryj?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/zjerryj">My Delicious Bookmarks &raquo;</a></p>
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/zhangji87@gmail.com?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Ji ZHANG -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jizhang';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://shzhangji.com/blog/2013/04/22/cia-storm/';
        var disqus_url = 'http://shzhangji.com/blog/2013/04/22/cia-storm/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
